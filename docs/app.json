{
	"metadata": {
		"type": "App"
	},
	"project": {
		"shadows": true,
		"shadowType": 1,
		"useLegacyLights": false,
		"toneMapping": 0,
		"toneMappingExposure": 1,
		"projectType": "EJXCube",
		"faceFront": "5be9dfb5-726e-4931-8e5c-49e3b6ccb589",
		"faceRight": "4dd5b36d-97e1-445b-aebb-acc109a4329e",
		"faceBack": "5be9dfb5-726e-4931-8e5c-49e3b6ccb589",
		"faceLeft": "4dd5b36d-97e1-445b-aebb-acc109a4329e",
		"faceTop": "6ee5ad3d-e96e-49a3-984b-02a57a8501bd",
		"faceBottom": "6ee5ad3d-e96e-49a3-984b-02a57a8501bd",
		"postprocessing": []
	},
	"camera": {
		"metadata": {
			"version": 4.5,
			"type": "Object",
			"generator": "Object3D.toJSON"
		},
		"object": {
			"uuid": "9a174d5b-0934-41bb-9294-e7e985a3d791",
			"type": "PerspectiveCamera",
			"name": "Camera",
			"layers": 1,
			"matrix": [0.9149204271985579,-1.7347234759768065e-17,0.403634255105792,0,0.03545743908664632,0.9961341145483813,-0.08037161094768486,0,-0.4020738513112039,0.08784546563658968,0.911383449629663,0,-0.812560274274741,0.17752891768187123,1.8418357308875386,1],
			"up": [0,1,0],
			"fov": 50,
			"zoom": 1,
			"near": 0.01,
			"far": 50,
			"focus": 10,
			"aspect": 1.6101344364012409,
			"filmGauge": 35,
			"filmOffset": 0
		}
	},
	"scene": {
		"metadata": {
			"version": 4.5,
			"type": "Object",
			"generator": "Object3D.toJSON"
		},
		"geometries": [
			{
				"uuid": "78e86c2d-8bdf-4f9b-a294-54fb3c3308fe",
				"type": "BoxGeometry",
				"width": 1,
				"height": 1,
				"depth": 1,
				"widthSegments": 1,
				"heightSegments": 30,
				"depthSegments": 1
			}],
		"materials": [
			{
				"uuid": "39956abf-96dc-4671-9c06-34c0ef0d6a46",
				"type": "ShaderMaterial",
				"name": "frontBG",
				"side": 1,
				"depthFunc": 3,
				"depthTest": true,
				"depthWrite": true,
				"colorWrite": true,
				"stencilWrite": false,
				"stencilWriteMask": 255,
				"stencilFunc": 519,
				"stencilRef": 0,
				"stencilFuncMask": 255,
				"stencilFail": 7680,
				"stencilZFail": 7680,
				"stencilZPass": 7680,
				"forceSinglePass": true,
				"fog": false,
				"glslVersion": null,
				"uniforms": {},
				"vertexShader": "\nuniform vec3 col1;\nuniform vec3 col2;\nuniform vec3 col3;\nvarying vec4 vCol;\n\nvoid main() {\n\n\tvec4 pos = vec4( position, 1.0 );\n\tvec4 worldPos = modelMatrix * pos;\n\tvec4 viewPos = viewMatrix * worldPos;\n\t\t\n\tvCol = mix( vec4( col1, 1.0 ), vec4( col2, 1.0 ), clamp( worldPos.y, -2.0, 0.0 ) + 0.5 ) ;\n\tvCol = mix( vCol, vec4( col3, 1.0 ), smoothstep( 0.0, 1.5, worldPos.y ) ) ;\n\t\n\tgl_Position = projectionMatrix * viewPos;\n\t\n}\n\n",
				"fragmentShader": "#define PI 3.141592653589793\nvarying vec4 vCol;\n\nhighp float rand( const in vec2 uv ) {\n  const highp float a = 12.9898, b = 78.233, c = 43758.5453;\n  highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n  return fract( sin( sn ) * c );\n}\n\nvec3 dithering( vec3 color ) {\n  float grid_position = rand( gl_FragCoord.xy );\n  vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n  dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n  return color + dither_shift_RGB;\n}\n\nvoid main() {\n\t\n\tgl_FragColor = vCol;\n\tgl_FragColor.rgb = LinearTosRGB( vec4( dithering( gl_FragColor.rgb ), 1.0 ) ).rgb;\n\t\n}"
			}],
		"object": {
			"uuid": "31517222-A9A7-4EAF-B5F6-60751C0BABA3",
			"type": "Scene",
			"name": "Scene",
			"layers": 1,
			"matrix": [1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],
			"up": [0,1,0],
			"children": [
				{
					"uuid": "142a9eef-0e7a-4d32-b93b-16616ff93beb",
					"type": "Group",
					"name": "faceBottom",
					"layers": 1,
					"matrix": [1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],
					"up": [0,1,0]
				},
				{
					"uuid": "6ee5ad3d-e96e-49a3-984b-02a57a8501bd",
					"type": "Group",
					"name": "faceTop",
					"layers": 1,
					"matrix": [1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],
					"up": [0,1,0]
				},
				{
					"uuid": "5be9dfb5-726e-4931-8e5c-49e3b6ccb589",
					"type": "Group",
					"name": "faceFront",
					"layers": 1,
					"matrix": [1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],
					"up": [0,1,0],
					"children": [
						{
							"uuid": "bb47580c-0ba3-4701-a8cc-a859ba88f405",
							"type": "Mesh",
							"name": "Box",
							"layers": 1,
							"matrix": [3,0,0,0,0,3,0,0,0,0,3,0,0,0,0,1],
							"up": [0,1,0],
							"geometry": "78e86c2d-8bdf-4f9b-a294-54fb3c3308fe",
							"material": "39956abf-96dc-4671-9c06-34c0ef0d6a46"
						}]
				},
				{
					"uuid": "1a5b1ee7-8132-4a2e-b2ef-5330c8c5e7fa",
					"type": "Group",
					"name": "faceBack",
					"layers": 1,
					"matrix": [1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],
					"up": [0,1,0]
				},
				{
					"uuid": "4dd5b36d-97e1-445b-aebb-acc109a4329e",
					"type": "Group",
					"name": "faceLeft",
					"layers": 1,
					"matrix": [1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],
					"up": [0,1,0]
				},
				{
					"uuid": "05006c5d-9feb-470c-977d-c0dd35238d4b",
					"type": "Group",
					"name": "faceRight",
					"layers": 1,
					"matrix": [1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],
					"up": [0,1,0]
				}]
		}
	},
	"scripts": {
		"31517222-A9A7-4EAF-B5F6-60751C0BABA3": [
			{
				"name": "main",
				"source": "//wander settings\nconst wanderSettings = {};\nwanderSettings.boundingSphereRadius = 0.5;\nwanderSettings.boundingForceMult = 1;\nwanderSettings.wanderSphereDistance = 0.1;\nwanderSettings.wanderSphereRadius = 8;\nwanderSettings.wanderAngleMaxChange = 12;\nwanderSettings.wanderBoundsAngleMaxChange = 8;\nwanderSettings.maxVelocity = 0.008;\nwanderSettings.maxSteeringForce = 8;\nwanderSettings.trailAvoidDist = 0.04;\nwanderSettings.trailDropDelay = 0.015;\nwanderSettings.numTrailSegments = 256;\nwanderSettings.dustAvoidDist = 0.04;\n\nconst agents = [];\nconst agentVizs = [];\n\nconst numDust = 4096;\nlet dust;\n\nfunction init() {\n\n\tconsole.log( \"init main\" );\n\tlet agentData1 = { wander: createWander( this ), id: 0 };\n\tagents.push( agentData1 );\n\tlet agentData2 = { wander: createWander( this ), id: 1 };\n\tagents.push( agentData2 );\n\n\tagentVizs.push( vis1( this.getObjectByName( \"faceFront\" ) ) );\n\tagentVizs.push( vis2( this.getObjectByName( \"faceLeft\" ) ) );\n\tagentVizs.push( vis3( this.getObjectByName( \"faceTop\" ) ) );\n\t\n\tdust = createDust();\n\tthis.getObjectByName( \"faceFront\" ).add( dust.points );\n\t\n}\n\nfunction update( event ) {\n\n\tconst deltaTime = event.delta * 0.001;\n\tconst time = event.time;\n\n\tfor ( let i = 0; i < agents.length; i++ ) {\n\t\n\t\tupdateAgent( agents[ i ], deltaTime );\n\t\t\n\t}\n\t\n\tfor ( let i = 0; i < agentVizs.length; i++ ) {\n\t\t\n\t\tagentVizs[ i ].update( deltaTime, time );\n\t\t\n\t}\n\t\n\tupdateDust( deltaTime );\n\t\n}\n\nfunction updateAgent( agentData, deltaTime ) {\n\n\tconst wander = agentData.wander;\n\t\n\twander.agentLookat.position.copy( wander.agentPoint );\n\n\twander.vec1.copy( wander.agentPoint );\n\n\tlet distanceFromCenter = wander.vec1.sub( wander.centerPoint ).length();\n\tif ( distanceFromCenter > wanderSettings.boundingSphereRadius ) {\n\n\t\twander.agentLookat.lookAt( wander.centerPoint );\n\t\twander.wanderAngle.rotateTowards( wander.agentLookat.quaternion, wanderSettings.wanderBoundsAngleMaxChange * deltaTime );\n\n\t} else {\n\n\t\twander.boundingForce.setScalar( 0 );\n\n\t}\n\n\t//attract heads\n\twander.trailAvoidForce.setScalar( 0 );\n\tfor ( let i = 0; i < agents.length; i++ ) {\n\n\t\tlet agent = agents[ i ];\n\t\tif ( agent.wander == wander ) {\n\n\t\t\tcontinue;\n\n\t\t}\n\n\t\tlet attactMult = 3;\n\t\twander.vec1.copy( agent.wander.agentPoint ).sub( wander.agentPoint ).normalize().multiplyScalar( attactMult );\n\t\twander.trailAvoidForce.add( wander.vec1 );\n\n\t}\n\n\t//avoid trails\n\tfor ( let i = 0; i < agents.length; i++ ) {\n\n\t\tlet agent = agents[ i ];\n\t\t\n\t\tlet jStart = ( i == agents[ i ].id ) ? Math.floor( wanderSettings.numTrailSegments ) * 0.5 : 0;\n\n\t\tfor ( let j = 0; j < wanderSettings.numTrailSegments; j++ ) {\n\n\t\t\twander.vec1.copy( agent.wander.trailSegments[ j ] );\n\t\t\tlet dist = wander.vec1.distanceToSquared( wander.agentPoint );\n\t\t\tif ( dist < wanderSettings.trailAvoidDist ) {\n\t\t\t\t\n\t\t\t\tlet forceMult = ( wanderSettings.trailAvoidDist - dist ) * 50.0;\n\t\t\t\twander.vec1.copy( wander.agentPoint ).sub( agent.wander.trailSegments[ j ] ).normalize().multiplyScalar( forceMult );\n\t\t\t\twander.trailAvoidForce.add( wander.vec1 );\n\n\t\t\t}\t\n\n\t\t}\n\n\t}\n\n\twander.wanderSphereCenter.copy( wander.currentVelocity ).normalize().multiplyScalar( wanderSettings.wanderSphereDistance );\n\twander.q1.random();\n\twander.wanderAngle.rotateTowards( wander.q1, wanderSettings.wanderAngleMaxChange * deltaTime );\n\twander.wanderForce.setScalar( 0 );\n\twander.wanderDir.copy( wander.forward ).applyQuaternion( wander.wanderAngle ).multiplyScalar( wanderSettings.wanderSphereRadius );\n\twander.wanderForce.copy( wander.wanderSphereCenter ).add( wander.wanderDir );\n\twander.wanderForce.clampLength( 0, wanderSettings.maxSteeringForce );\n\n\twander.wanderForce.add( wander.trailAvoidForce );\n\twander.vec1.copy( wander.wanderForce ).multiplyScalar( deltaTime );\n\twander.currentVelocity.add( wander.vec1 );\n\twander.vec1.copy( wander.boundingForce ).multiplyScalar( deltaTime );\n\twander.currentVelocity.add( wander.vec1 );\n\twander.currentVelocity.clampLength( 0, wanderSettings.maxVelocity );\n\n\twander.agentPoint.add( wander.currentVelocity );\n\t\n\twander.trailDropTick += deltaTime;\n\tif ( wander.trailDropTick > wanderSettings.trailDropDelay ) {\n\t\n\t\twander.trailDropTick = 0;\n\n\t\tfor( let i = wanderSettings.numTrailSegments - 1; i > 0; i-- ) {\n\n\t\t\twander.trailSegments[ i ].copy( wander.trailSegments[ i - 1 ] );\n\n\t\t}\n\t\twander.trailSegments[ 0 ].copy( wander.agentPoint );\n\t\t\n\t}\n\t\n}\n\nfunction createWander( scene ) {\n\n\tconst wander = {};\n\t\n\twander.vec1 = new THREE.Vector3();\n\twander.vec2 = new THREE.Vector3();\n\twander.vec3 = new THREE.Vector3();\n\twander.vec4 = new THREE.Vector3();\n\twander.q1 = new THREE.Quaternion();\n\twander.forward = new THREE.Vector3( 0, 0, 1.0 );\n\t\n\twander.agentPoint = new THREE.Vector3(  0.05, 0.05, 0.05 );\n\twander.agentLookat = new THREE.Object3D();\n\t\n\twander.currentPosition = new THREE.Vector3();\n\n\twander.centerPoint = new THREE.Vector3();\n\n\twander.currentVelocity = new THREE.Vector3().randomDirection().multiplyScalar( wanderSettings.maxVelocity );\n\twander.maxVelocitySq = wanderSettings.maxVelocity * wanderSettings.maxVelocity;\n\n\twander.boundingForce = new THREE.Vector3();\n\n\twander.wanderAngle = new THREE.Quaternion().random();\n\twander.wanderSphereCenter = new THREE.Vector3();\n\twander.wanderForce = new THREE.Vector3();\n\twander.wanderDir = new THREE.Vector3();\n\n\twander.trailAvoidDist = wanderSettings.trailAvoidDist * wanderSettings.trailAvoidDist;\n\twander.trailAvoidForce = new THREE.Vector3();\n\twander.trailDropTick = 0;\n\twander.numTrailSegments = wanderSettings.numTrailSegments;\n\twander.trailSegments = [];\n\tfor ( let i = 0; i < wanderSettings.numTrailSegments; i++ ) {\n\t\t\n\t\twander.trailSegments.push( new THREE.Vector3() );\n\t\t\n\t}\t\n\t\t\t\t\n\treturn wander;\n\t\n}\n\n//\n//dust\n//\n\nconst dustVert = `\n\nuniform vec3 col;\nuniform float pixelRatio;\nvarying vec3 vCol;\n\nvoid main() {\n\n\tvec4 vPos = vec4( position, 1.0 );\n    vec4 worldPos = modelMatrix * vPos;\n    vec4 viewPos = viewMatrix * worldPos;\n\t\n\tvCol = col;\n\tgl_PointSize = ( 300.0 / -viewPos.z ) * 0.024 * pixelRatio;\n    gl_Position = projectionMatrix * viewPos;\n\n}\n`;\n\nconst dustFrag = `\n\nuniform float uTime;\nvarying vec3 vCol;\n\nvoid main() {\n\n\tif ( length( gl_PointCoord - vec2( 0.5, 0.5 ) ) > 0.475 ) discard;\n    gl_FragColor = vec4( vCol, 1.0 );\n\n}\n`;\n\nfunction createDust() {\n\n\tconst dust = {};\n\tconst geo = new THREE.BufferGeometry();\n\tconst points = [];\n\tconst velocities = [];\n\tlet v = new THREE.Vector3();\n\tfor ( let i = 0; i < numDust; i++ ) {\n\t\t\n\t\tlet x = THREE.MathUtils.randFloatSpread( 1.0 );\n\t\tlet y = THREE.MathUtils.randFloatSpread( 1.0 );\n\t\tlet z = THREE.MathUtils.randFloatSpread( 1.0 );\n\t\tpoints.push( x, y, z );\n\t\t\n\t\tv.randomDirection().multiplyScalar( 0.02 );\n\t\tvelocities.push( v.clone() );\n\t\t\n\t}\n\t\n\tconst posAttribute = new THREE.Float32BufferAttribute( points, 3 );\n\tposAttribute.setUsage( THREE.StreamDrawUsage );\n\tgeo.setAttribute( \"position\", posAttribute );\n\t\t\t\t\t \n\tconst mat = new THREE.ShaderMaterial( { uniforms: { col: { value: new THREE.Color( 0x282037 ) }, pixelRatio: { value: window.devicePixelRatio } }, vertexShader: dustVert, fragmentShader: dustFrag } );\n\tmat.blending = THREE.AdditiveBlending;\n\tconst dustPoints = new THREE.Points( geo, mat );\n\n\tdust.points = dustPoints;\n\tdust.geo = geo;\n\tdust.mat = mat;\n\tdust.velocities = velocities;\n\tdust.pos = new THREE.Vector3();\n\tdust.vec1 = new THREE.Vector3();\n\tdust.moveForce = new THREE.Vector3();\n\n\treturn dust;\n\t\t\n}\n\nfunction updateDust( deltaTime ) {\n\n\tconst posAttribute = dust.geo.getAttribute( \"position\" );\n\t\n\tconst border = 0.5;\n\t\n\tfor ( let i = 0; i < numDust; i++ ) {\n\t\t\n\t\tlet x = posAttribute.array[ i * 3 ];\n\t\tlet y = posAttribute.array[ i * 3 + 1 ];\n\t\tlet z = posAttribute.array[ i * 3 + 2 ];\n\t\t\n\t\tlet v = dust.velocities[ i ];\n\n\t\tif ( x < -border ) {\n\t\t\t\n\t\t\tv.x = Math.abs( v.x );\n\t\t\t\n\t\t} else if ( x > border ) {\n\t\t\t\n\t\t\tv.x = -Math.abs( v.x );\n\t\t\t\n\t\t}\n\n\t\tif ( y < -border ) {\n\t\t\t\n\t\t\tv.y = Math.abs( v.y );\n\t\t\t\n\t\t} else if ( y > border ) {\n\t\t\t\n\t\t\tv.y = -Math.abs( v.y );\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( z < -border ) {\n\t\t\t\n\t\t\tv.z = Math.abs( v.z );\n\t\t\t\n\t\t} else if ( z > border ) {\n\t\t\t\n\t\t\tv.z = -Math.abs( v.z );\n\t\t\t\n\t\t}\n\t\t\n\t\tdust.moveForce.set( 0.0, 0.0, 0.0 );\n\t\tfor ( let i = 0; i < agents.length; i++ ) {\n\n\t\t\tlet agent = agents[ i ];\n\n\t\t\tfor ( let j = 0; j < wanderSettings.numTrailSegments; j++ ) {\n\n\t\t\t\tdust.pos.set( x, y, z );\n\t\t\t\tdust.vec1.copy( agent.wander.trailSegments[ j ] );\n\t\t\t\tlet dist = dust.vec1.distanceToSquared( dust.pos );\n\t\t\t\tif ( dist < wanderSettings.dustAvoidDist ) {\n\n\t\t\t\t\tlet forceMult = ( wanderSettings.dustAvoidDist - dist ) * 0.4;\n\t\t\t\t\tdust.vec1.copy( dust.pos ).sub( agent.wander.trailSegments[ j ] ).normalize().multiplyScalar( forceMult );\n\t\t\t\t\tdust.moveForce.add( dust.vec1 );\n\n\t\t\t\t}\t\n\n\t\t\t}\n\n\t\t}\n\t\t\n\t\tdust.vec1.copy( v ).add( dust.moveForce );\n\t\t\n\t\tx += dust.vec1.x * deltaTime;\n\t\ty += dust.vec1.y * deltaTime;\n\t\tz += dust.vec1.z * deltaTime;\n\t\tposAttribute.setXYZ( i, x, y, z );\n\t\t\n\t}\t\n\tposAttribute.needsUpdate = true;\n\t\n}\n\n//\n//vis1 - front/back\n//\n\nconst vis1SpikeVert = `\n\nuniform vec3 col1;\nvarying vec3 vCol;\n\nvoid main() {\n\n\tvec4 vPos = vec4( position, 1.0 );\n    vec4 iPos = instanceMatrix * vPos;\n    vec4 worldPos = modelMatrix * iPos;\n    vec4 viewPos = viewMatrix * worldPos;\n\t\n\tfloat fade = 0.7;\n\t//vCol = mix( col2 * fade, col1 * fade, smoothstep( -0.8, 1.2, worldPos.z ) );\n\tvCol = col1 * smoothstep( 0.05, 0.09, vPos.y );\n    gl_Position = projectionMatrix * viewPos;\n\n}\n`;\n\nconst vis1SpikeFrag = `\n\nuniform float uTime;\nvarying vec3 vCol;\n\nvoid main() {\n\n    gl_FragColor = vec4( vCol, 1.0 );\n\n}\n`;\n\nconst vis1BodyVert = `\n\n#define PI 3.141592653589793\nattribute vec3 rndPos;\nattribute vec3 dir;\nattribute float t;\nuniform vec3 col1;\nuniform vec3 col2;\nuniform float uTime;\nvarying vec3 vCol;\n\nvoid main() {\n\n\tfloat scXY = smoothstep( 0.0, 0.1, t ) * ( 1.0 - smoothstep( 0.9, 1.0, t ) ) * 0.4;\n\tfloat sc = max( scXY + sin( t * PI * 2.0 * 30.0 + uTime * -3.0 ) * ( scXY * 0.9 ), 0.3 );\n\t\n\tvec3 pos = position;\n\tpos *= sc;\n\t\n\tfloat rndMult = max ( scXY + sin( t * PI * 4.0 ) * 0.4 + sin( t * PI * 5.0 - uTime * 4.0 ) * 0.4, 0.1 );\n\n\tvec4 vPos = vec4( pos + rndPos * rndMult, 1.0 );\n\t\n    vec4 iPos = instanceMatrix * vPos;\n    vec4 worldPos = modelMatrix * iPos;\n    vec4 viewPos = viewMatrix * worldPos;\n\t\n\tvCol = mix( col1, col2, smoothstep( -0.5, 0.5, dot( cameraPosition - worldPos.xyz, dir ) ) );\n\t\n    gl_Position = projectionMatrix * viewPos;\n\n}\n`;\n\nconst vis1BodyFrag = `\n\nuniform float uTime;\n\nvarying vec3 vCol;\n\nvoid main() {\n\n    gl_FragColor = vec4( vCol, 1.0 );\n\n}\n`;\n\n\n\nfunction vis1( faceGroup ) {\n\t\t\n\t//vis\n\tconst vis = {};\n\t\n\tvis.spineElemR = 0.01;\n\tvis.spineElemH = 0.04;\n\tvis.bodyElemScale = 0.02;\n\tvis.numSpineInstances = 1024;\n\tvis.numBodyInstances = 512;\n\tvis.numSpineLoops = 323;\n\tvis.visAgents = [];\n\tvis.cols = [ 0xdf4266, 0xd246d8 ];\n\tvis.bodyCols = [ 0x43adc8, 0xc84f43 ];\n\t\n\tvis.pos = new THREE.Vector3();\n\tvis.vec1 = new THREE.Vector3();\n\tvis.vec2 = new THREE.Vector3();\n\tvis.vec3 = new THREE.Vector3();\n\tvis.mat3 = new THREE.Matrix3();\n\tvis.mat4 = new THREE.Matrix4();\n\tvis.matRot4 = new THREE.Matrix4();\n\tvis.q1 = new THREE.Quaternion();\n\tvis.q2 = new THREE.Quaternion();\n\tvis.q3 = new THREE.Quaternion();\n\tvis.scale = new THREE.Vector3();\n\tvis.forward = new THREE.Vector3( 0, 0, 1.0 );\n\tvis.up = new THREE.Vector3( 0, 1.0, 0 );\n\n\tvis.tick = 0;\n\t\n\tvis.faceGroup = faceGroup;\n\t\n\tfor ( let i = 0; i < agents.length; i++ ) {\n\n\t\tconst geo = new THREE.ConeGeometry( vis.spineElemR, vis.spineElemH, 5, 1 );\n\t\tgeo.translate( 0, vis.spineElemH * 0.5 + 0.05, 0 );\n\t\t\n\t\tconst spikeUniforms = {\n\t\t\t\"col1\": { value: new THREE.Color( vis.cols[ i ] ) },\n\t\t};\n\t\tconst mat = new THREE.ShaderMaterial( { uniforms: spikeUniforms, vertexShader: vis1SpikeVert, fragmentShader: vis1SpikeFrag } );\n\t\tmat.blending = THREE.AdditiveBlending;\n\t\t//const mat = new THREE.MeshBasicMaterial( { color: vis.cols[ i ] } );\n\n\t\tconst spikeMesh = new THREE.InstancedMesh( geo, mat, vis.numSpineInstances );\n\t\tspikeMesh.instanceMatrix.setUsage( THREE.StreamDrawUsage );\n\t\tfaceGroup.add( spikeMesh );\n\n\t\tconst bodyUniforms = {\n\t\t\t\"col1\": { value: new THREE.Color( vis.bodyCols[ i ] ) },\n\t\t\t\"col2\": { value: new THREE.Color( vis.bodyCols[ 1 - i ] ) },\n\t\t\t\"uTime\": { value: 0 }\n\t\t};\n\t\tconst bodyMat = new THREE.ShaderMaterial( { uniforms: bodyUniforms, vertexShader: vis1BodyVert, fragmentShader: vis1BodyFrag } );\n\t\tbodyMat.blending = THREE.AdditiveBlending;\n\n\t\tconst bodyGeo = new THREE.IcosahedronGeometry( vis.bodyElemScale, 0 );\n\t\tconst bodyMesh = new THREE.InstancedMesh( bodyGeo, bodyMat, vis.numBodyInstances );\n\t\tbodyMesh.instanceMatrix.setUsage( THREE.StreamDrawUsage );\n\t\tfaceGroup.add( bodyMesh );\t\t\n\n\t\tconst agentData = { agent: agents[ i ], spikeMesh: spikeMesh, bodyMesh: bodyMesh, bodyUniforms: bodyUniforms, spikeData: [] };\n\t\t\t\t\t\t\t\t\n\t\tfor ( let i = 0; i < vis.numSpineInstances; i++ ) {\n\n\t\t\tagentData.spikeData.push( { q: new THREE.Quaternion() } );\n\n\t\t}\n\t\t\n\t\tconst bodyDirs = new Float32Array( vis.numBodyInstances * 3 );\n\t\tconst bodyRndPos = new Float32Array( vis.numBodyInstances * 3 );\n\t\tconst bodyT = new Float32Array( vis.numBodyInstances );\n\t\tfor ( let i = 0; i < vis.numBodyInstances; i++ ) {\n\n\t\t\tlet rnd = new THREE.Vector3().randomDirection().multiplyScalar( 0.05 );\n\t\t\tbodyRndPos[ i * 3 ] = rnd.x;\n\t\t\tbodyRndPos[ i * 3 + 1 ] = rnd.y;\n\t\t\tbodyRndPos[ i * 3 + 2 ] = rnd.z;\n\t\t\tbodyDirs[ i * 3 ] = 0;\n\t\t\tbodyDirs[ i * 3 + 1 ] = 0;\n\t\t\tbodyDirs[ i * 3 + 2 ] = 0;\n\n\t\t\tbodyT[ i ] = i / ( vis.numBodyInstances - 1 );\n\n\t\t}\n\t\t\n\t\tbodyGeo.setAttribute( 'dir', new THREE.InstancedBufferAttribute( bodyDirs, 3 ) );\n\t\tbodyGeo.setAttribute( 'rndPos', new THREE.InstancedBufferAttribute( bodyRndPos, 3 ) );\n\t\tbodyGeo.setAttribute( 't', new THREE.InstancedBufferAttribute( bodyT, 1 ) );\n\t\t\t\t\n\t\tvis.visAgents.push( agentData );\n\t\t\n\t}\n\t\n\tvis.update = function( deltaTime, time ) {\n\n\t\tthis.tick += deltaTime;\n\t\t\n\t\tlet visAgent, visAgentWander;\n\t\tfor ( let j = 0; j < vis.visAgents.length; j++ ) {\n\t\t\t\n\t\t\tvisAgent = this.visAgents[ j ];\n\t\t\tvisAgentWander = visAgent.agent.wander;\n\t\t\tvisAgent.bodyUniforms.uTime.value = this.tick;\n\t\t\t\n\t\t\tfor ( let i = 0; i < this.numSpineInstances; i++ ) {\n\n\t\t\t\tlet t = i / this.numSpineInstances;\n\t\t\t\tlet segmentI = Math.floor( t * visAgentWander.numTrailSegments );\n\t\t\t\tlet segmentT = t * visAgentWander.numTrailSegments - Math.floor( t * visAgentWander.numTrailSegments );\n\t\t\t\tlet spikeData = visAgent.spikeData[ i ];\n\n\t\t\t\tif ( segmentI < visAgentWander.numTrailSegments - 1 ) {\n\n\t\t\t\t\tthis.pos.copy( visAgentWander.trailSegments[ segmentI ] ).lerp( visAgentWander.trailSegments[ segmentI + 1 ], segmentT );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis.pos.copy( visAgentWander.trailSegments[ segmentI ] );\n\n\t\t\t\t}\n\n\n\t\t\t\tif ( segmentI == 0 ) {\n\n\t\t\t\t\tthis.vec2.copy( this.pos );\n\t\t\t\t\tthis.vec2.add( this.vec1.copy( visAgentWander.trailSegments[ 0 ] ).sub( visAgentWander.trailSegments[ 1 ] ).normalize() );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis.vec2.copy( this.pos );\n\t\t\t\t\tthis.vec2.add( this.vec1.copy( visAgentWander.trailSegments[ segmentI - 1 ] ).sub( visAgentWander.trailSegments[ segmentI ] ).normalize() );\n\n\t\t\t\t}\n\n\t\t\t\tthis.matRot4.lookAt( this.pos, this.vec2, this.up );\n\t\t\t\tthis.q1.setFromRotationMatrix( this.matRot4 );\n\t\t\t\t\n\t\t\t\tthis.q2.setFromAxisAngle( this.forward, t * Math.PI * 2 * this.numSpineLoops + this.tick * 1.0 );\n\t\t\t\tthis.q1.multiply( this.q2 );\n\t\t\t\t\n\t\t\t\tspikeData.q.slerp( this.q1, deltaTime * 2.0 );\n\n\t\t\t\tlet scXY = THREE.MathUtils.smoothstep( t, 0, 0.1 ) * ( 1.0 - THREE.MathUtils.smoothstep( t, 0.9, 1.0 ) ) * 1.0;\n\t\t\t\tlet sc = Math.max( scXY + Math.sin( t * Math.PI * 2 * 30.0 + this.tick * -3.0 ) * ( scXY * 0.9 ), 0.3 );\n\t\t\t\tsc = scXY;\n\t\t\t\tthis.scale.setScalar( sc );\n\n\t\t\t\tlet rndMult = Math.max ( scXY + Math.sin( t * Math.PI * 4 ) * 0.4 + Math.sin( t * Math.PI * 5 - this.tick * 4.0 ) * 0.4, 0.1 );\n\n\t\t\t\tthis.mat4.compose( this.pos, spikeData.q, this.scale );\n\n\t\t\t\tvisAgent.spikeMesh.setMatrixAt( i, this.mat4 );\n\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tlet bodyDirs = visAgent.bodyMesh.geometry.getAttribute( \"dir\" );\n\t\t\t\n\t\t\tfor ( let i = 0; i < this.numBodyInstances; i++ ) {\n\n\t\t\t\tlet t = i / this.numBodyInstances;\n\t\t\t\tlet segmentI = Math.floor( t * visAgentWander.numTrailSegments );\n\t\t\t\tlet segmentT = t * visAgentWander.numTrailSegments - Math.floor( t * visAgentWander.numTrailSegments );\n\n\t\t\t\tif ( segmentI < visAgentWander.numTrailSegments - 1 ) {\n\n\t\t\t\t\tthis.pos.copy( visAgentWander.trailSegments[ segmentI ] ).lerp( visAgentWander.trailSegments[ segmentI + 1 ], segmentT );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis.pos.copy( visAgentWander.trailSegments[ segmentI ] );\n\n\t\t\t\t}\n\n\n\t\t\t\tif ( segmentI == 0 ) {\n\n\t\t\t\t\tthis.vec2.copy( this.pos );\n\t\t\t\t\tthis.vec2.add( this.vec1.copy( visAgentWander.trailSegments[ 0 ] ).sub( visAgentWander.trailSegments[ 1 ] ).normalize() );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis.vec2.copy( this.pos );\n\t\t\t\t\tthis.vec2.add( this.vec1.copy( visAgentWander.trailSegments[ segmentI - 1 ] ).sub( visAgentWander.trailSegments[ segmentI ] ).normalize() );\n\n\t\t\t\t}\n\t\t\t\tbodyDirs.setXYZ( i, this.vec2.x, this.vec2.y, this.vec2.z );\n\t\t\t\t\n\t\t\t\tthis.scale.setScalar( 1.0 );\n\t\t\t\tthis.mat4.compose( this.pos, this.q3, this.scale );\n\n\t\t\t\tvisAgent.bodyMesh.setMatrixAt( i, this.mat4 );\t\t\t\t\n\n\t\t\t}\t\t\t\n\n\t\t\tvisAgent.spikeMesh.instanceMatrix.needsUpdate = true;\n\t\t\tvisAgent.bodyMesh.instanceMatrix.needsUpdate = true;\n\t\t\tbodyDirs.needsUpdate = true;\t\t\t\n\n\t\t}\n\t\t\n\t}\n\n\treturn vis;\n\t\n}\n\n\n//\n//vis2 - left/right\n//\n\nconst vis2SpikeVert = `\n\nuniform vec3 col1;\nuniform vec3 col2;\nvarying vec3 vCol;\n\nvoid main() {\n\n    vec3 pos = ( instanceMatrix * vec4( position, 1.0 ) ).xyz;\n    vec3 worldPos = ( modelMatrix * vec4( pos, 1.0 ) ).xyz;\n    vec4 mvPosition = viewMatrix * vec4( worldPos, 1.0 );\n\t\n\tvCol = mix( col2, col1, smoothstep( -0.8, 1.2, worldPos.z ) );\n    gl_Position = projectionMatrix * mvPosition;\n\n}\n`;\n\nconst vis2SpikeFrag = `\n\nuniform float uTime;\n\nvarying vec3 vCol;\n\nvoid main() {\n\n    gl_FragColor = vec4( vCol, 1.0 );\n\n}\n`;\n\n\nfunction vis2( faceGroup ) {\n\t\n\t//front lighting\n\tconst frontLight = new THREE.DirectionalLight( 0xffffff, 0.8 );\n\tfrontLight.position.set( 0, 1.0, 1.0 );\n\tfaceGroup.add( frontLight );\n\tconst frontAmbLight = new THREE.HemisphereLight( 0xFF0000, 0x0000FF, 0.5 );\n\tfaceGroup.add( frontAmbLight );\n\t\n\t//vis\n\tconst vis = {};\n\t\n\tvis.elemScale = 0.04;\n\tvis.bodyElemScale = 0.01;\n\tvis.numSpineInstances = 512;\n\t\n\tvis.visAgents = [];\n\tvis.cols = [ 0xFF00FF, 0x00FFFF ];\n\t\n\tvis.pos = new THREE.Vector3();\n\tvis.vec1 = new THREE.Vector3();\n\tvis.vec2 = new THREE.Vector3();\n\tvis.vec3 = new THREE.Vector3();\n\tvis.mat3 = new THREE.Matrix3();\n\tvis.mat4 = new THREE.Matrix4();\n\tvis.matRot4 = new THREE.Matrix4();\n\tvis.q1 = new THREE.Quaternion();\n\tvis.q2 = new THREE.Quaternion();\n\tvis.scale = new THREE.Vector3();\n\tvis.forward = new THREE.Vector3( 0, 0, 1.0 );\n\tvis.up = new THREE.Vector3( 0, 1.0, 0 );\n\n\tvis.tick = 0;\n\t\n\tvis.faceGroup = faceGroup;\n\t\n\tfor ( let i = 0; i < agents.length; i++ ) {\n\n\t\tconst geo = new THREE.ConeGeometry( vis.elemScale, vis.elemScale * 2.0, 3, 1 );\n\t\tgeo.translate( 0, vis.elemScale * 2.0, 0 );\n\t\t\n\t\tconst spikeUniforms = {\n\t\t\t\"col1\": { value: new THREE.Color( vis.cols[ i ] ) },\n\t\t\t\"col2\": { value: new THREE.Color( 0x000000 ) },\n\t\t};\n\t\tconst mat = new THREE.ShaderMaterial( { uniforms: spikeUniforms, vertexShader: vis2SpikeVert, fragmentShader: vis2SpikeFrag } );\n\t\t//const mat = new THREE.MeshBasicMaterial( { color: vis.cols[ i ] } );\n\n\t\tconst visMesh = new THREE.InstancedMesh( geo, mat, vis.numSpineInstances );\n\t\tvisMesh.instanceMatrix.setUsage( THREE.StreamDrawUsage );\n\t\tfaceGroup.add( visMesh );\n\n\t\tconst agentData = { agent: agents[ i ], mesh: visMesh, elemData: [] };\n\t\tfor ( let i = 0; i < vis.numSpineInstances; i++ ) {\n\n\t\t\tagentData.elemData.push( { rnd: new THREE.Vector3().randomDirection().multiplyScalar( 0.05 ), q: new THREE.Quaternion() } );\n\n\t\t}\n\t\t\n\t\tvis.visAgents.push( agentData );\n\t\t\n\t}\n\t\n\tvis.update = function( deltaTime, time ) {\n\n\t\tthis.tick += deltaTime;\n\t\t\n\t\tlet visAgent, visAgentWander;\n\t\tfor ( let j = 0; j < vis.visAgents.length; j++ ) {\n\t\t\t\n\t\t\tvisAgent = this.visAgents[ j ];\n\t\t\tvisAgentWander = visAgent.agent.wander;\n\t\t\t\n\t\t\tfor ( let i = 0; i < this.numSpineInstances; i++ ) {\n\n\t\t\t\tlet t = i / this.numSpineInstances;\n\t\t\t\tlet segmentI = Math.floor( t * visAgentWander.numTrailSegments );\n\t\t\t\tlet segmentT = t * visAgentWander.numTrailSegments - Math.floor( t * visAgentWander.numTrailSegments );\n\t\t\t\tlet data = visAgent.elemData[ i ];\n\n\t\t\t\tif ( segmentI < visAgentWander.numTrailSegments - 1 ) {\n\n\t\t\t\t\tthis.pos.copy( visAgentWander.trailSegments[ segmentI ] ).lerp( visAgentWander.trailSegments[ segmentI + 1 ], segmentT );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis.pos.copy( visAgentWander.trailSegments[ segmentI ] );\n\n\t\t\t\t}\n\n\n\t\t\t\tif ( segmentI == 0 ) {\n\n\t\t\t\t\tthis.vec2.copy( this.pos );\n\t\t\t\t\tthis.vec2.add( this.vec1.copy( visAgentWander.trailSegments[ 0 ] ).sub( visAgentWander.trailSegments[ 1 ] ).normalize() );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis.vec2.copy( this.pos );\n\t\t\t\t\tthis.vec2.add( this.vec1.copy( visAgentWander.trailSegments[ segmentI - 1 ] ).sub( visAgentWander.trailSegments[ segmentI ] ).normalize() );\n\n\t\t\t\t}\n\n\t\t\t\tthis.matRot4.lookAt( this.pos, this.vec2, this.up );\n\t\t\t\tthis.q1.setFromRotationMatrix( this.matRot4 );\n\t\t\t\t\n\t\t\t\tthis.q2.setFromAxisAngle( this.forward, t * Math.PI * 2 * 4 + this.tick * 5.0 );\n\t\t\t\tthis.q1.multiply( this.q2 );\n\t\t\t\t\n\t\t\t\tdata.q.slerp( this.q1, deltaTime * 2.0 );\n\n\t\t\t\tlet scXY = THREE.MathUtils.smoothstep( t, 0, 0.1 ) * ( 1.0 - THREE.MathUtils.smoothstep( t, 0.9, 1.0 ) ) * 1.0;\n\t\t\t\tlet sc = Math.max( scXY + Math.sin( t * Math.PI * 2 * 30.0 + this.tick * -3.0 ) * ( scXY * 0.9 ), 0.3 );\n\t\t\t\tsc = scXY;\n\t\t\t\tthis.scale.setScalar( sc );\n\n\t\t\t\tlet rndMult = Math.max ( scXY + Math.sin( t * Math.PI * 4 ) * 0.4 + Math.sin( t * Math.PI * 5 - this.tick * 4.0 ) * 0.4, 0.1 );\n\t\t\t\t//this.vec3.copy( data.rnd ).multiplyScalar( rndMult );\n\t\t\t\t//this.pos.add( this.vec3 );\n\n\t\t\t\tthis.mat4.compose( this.pos, data.q, this.scale );\n\n\t\t\t\tvisAgent.mesh.setMatrixAt( i, this.mat4 );\n\n\t\t\t}\n\n\t\t\tvisAgent.mesh.instanceMatrix.needsUpdate = true;\n\n\t\t}\n\t\t\n\t}\n\n\treturn vis;\n\t\n}\n\n\n\n\n//\n//vis3 - top/bottom\n//\n\nconst vis3SpikeVert = `\n\nuniform vec3 col1;\nuniform vec3 col2;\nvarying vec3 vCol;\n\nvoid main() {\n\n    vec3 pos = ( instanceMatrix * vec4( position, 1.0 ) ).xyz;\n    vec3 worldPos = ( modelMatrix * vec4( pos, 1.0 ) ).xyz;\n    vec4 mvPosition = viewMatrix * vec4( worldPos, 1.0 );\n\t\n\tvCol = mix( col2, col1, smoothstep( -0.8, 1.2, worldPos.z ) );\n    gl_Position = projectionMatrix * mvPosition;\n\n}\n`;\n\nconst vis3SpikeFrag = `\n\nuniform float uTime;\n\nvarying vec3 vCol;\n\nvoid main() {\n\n    gl_FragColor = vec4( vCol, 1.0 );\n\n}\n`;\n\n\nfunction vis3( faceGroup ) {\n\t\t\n\t//vis\n\tconst vis = {};\n\t\n\tvis.cubeW = 1.0;\n\t\n\tvis.numConnections = 256;\n\t\n\tvis.visAgents = [];\n\tvis.cols = [ 0xff4949, 0x70ffb0 ];\n\t\n\tvis.pos = new THREE.Vector3();\n\tvis.vec1 = new THREE.Vector3();\n\tvis.vec2 = new THREE.Vector3();\n\tvis.vec3 = new THREE.Vector3();\n\tvis.mat3 = new THREE.Matrix3();\n\tvis.mat4 = new THREE.Matrix4();\n\tvis.matRot4 = new THREE.Matrix4();\n\tvis.q1 = new THREE.Quaternion();\n\tvis.q2 = new THREE.Quaternion();\n\tvis.scale = new THREE.Vector3();\n\tvis.forward = new THREE.Vector3( 0, 0, 1.0 );\n\tvis.up = new THREE.Vector3( 0, 1.0, 0 );\n\n\tvis.tick = 0;\n\t\n\tvis.faceGroup = faceGroup;\n\t\n\tfor ( let i = 0; i < agents.length; i++ ) {\n\n\t\tconst agentData = { agent: agents[ i ] };\n\t\tvis.visAgents.push( agentData );\n\t\t\n\t}\t\n\n\t\n\tvis.side1 = createLatticeSide( vis.cols[ 0 ], -1 );\n\tfaceGroup.add( vis.side1.line );\n\tvis.side2 = createLatticeSide( vis.cols[ 1 ], 1 );\n\tfaceGroup.add( vis.side2.line );\n\t\n\tvis.update = function( deltaTime, time ) {\n\n\t\tthis.tick += deltaTime;\n\n\t\tlet posAttribute = this.side1.line.geometry.getAttribute( \"position\" );\n\t\tlet x, y, z;\n\t\tfor ( let i = 0; i < 256; i++ ) {\n\n\t\t\tlet id = i * 2 + 1;\n\t\t\t\n\t\t\tlet segment = this.visAgents[ 0 ].agent.wander.trailSegments[ i ];\n\t\t\t\n\t\t\tposAttribute.setXYZ( id, segment.x, segment.y, segment.z );\n\t\t\t\n\t\t}\n\t\tposAttribute.needsUpdate = true;\n\n\t\tposAttribute = this.side2.line.geometry.getAttribute( \"position\" );\n\t\tfor ( let i = 0; i < 256; i++ ) {\n\n\t\t\tlet id = i * 2 + 1;\n\t\t\t\n\t\t\tlet segment = this.visAgents[ 1 ].agent.wander.trailSegments[ i ];\n\t\t\t\n\t\t\tposAttribute.setXYZ( id, segment.x, segment.y, segment.z );\n\t\t\t\n\t\t}\n\t\tposAttribute.needsUpdate = true;\t\t\n\t\t\n\t\t/*\n\t\tlet visAgent, visAgentWander;\n\t\tfor ( let j = 0; j < vis.visAgents.length; j++ ) {\n\t\t\t\n\t\t\tvisAgent = this.visAgents[ j ];\n\t\t\tvisAgentWander = visAgent.agent.wander;\n\t\t\t\n\t\t\tfor ( let i = 0; i < this.numSpineInstances; i++ ) {\n\n\t\t\t\tlet t = i / this.numSpineInstances;\n\t\t\t\tlet segmentI = Math.floor( t * visAgentWander.numTrailSegments );\n\t\t\t\tlet segmentT = t * visAgentWander.numTrailSegments - Math.floor( t * visAgentWander.numTrailSegments );\n\t\t\t\tlet spikeData = visAgent.spikeData[ i ];\n\n\t\t\t\tif ( segmentI < visAgentWander.numTrailSegments - 1 ) {\n\n\t\t\t\t\tthis.pos.copy( visAgentWander.trailSegments[ segmentI ] ).lerp( visAgentWander.trailSegments[ segmentI + 1 ], segmentT );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis.pos.copy( visAgentWander.trailSegments[ segmentI ] );\n\n\t\t\t\t}\n\n\n\t\t\t\tif ( segmentI == 0 ) {\n\n\t\t\t\t\tthis.vec2.copy( this.pos );\n\t\t\t\t\tthis.vec2.add( this.vec1.copy( visAgentWander.trailSegments[ 0 ] ).sub( visAgentWander.trailSegments[ 1 ] ).normalize() );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis.vec2.copy( this.pos );\n\t\t\t\t\tthis.vec2.add( this.vec1.copy( visAgentWander.trailSegments[ segmentI - 1 ] ).sub( visAgentWander.trailSegments[ segmentI ] ).normalize() );\n\n\t\t\t\t}\n\n\t\t\t\tthis.matRot4.lookAt( this.pos, this.vec2, this.up );\n\t\t\t\tthis.q1.setFromRotationMatrix( this.matRot4 );\n\t\t\t\t\n\t\t\t\tthis.q2.setFromAxisAngle( this.forward, t * Math.PI * 2 * this.numSpineLoops + this.tick * 1.0 );\n\t\t\t\tthis.q1.multiply( this.q2 );\n\t\t\t\t\n\t\t\t\tspikeData.q.slerp( this.q1, deltaTime * 2.0 );\n\n\t\t\t\tlet scXY = THREE.MathUtils.smoothstep( t, 0, 0.1 ) * ( 1.0 - THREE.MathUtils.smoothstep( t, 0.9, 1.0 ) ) * 1.0;\n\t\t\t\tlet sc = Math.max( scXY + Math.sin( t * Math.PI * 2 * 30.0 + this.tick * -3.0 ) * ( scXY * 0.9 ), 0.3 );\n\t\t\t\tsc = scXY;\n\t\t\t\tthis.scale.setScalar( sc );\n\n\t\t\t\tlet rndMult = Math.max ( scXY + Math.sin( t * Math.PI * 4 ) * 0.4 + Math.sin( t * Math.PI * 5 - this.tick * 4.0 ) * 0.4, 0.1 );\n\n\t\t\t\tthis.mat4.compose( this.pos, spikeData.q, this.scale );\n\n\t\t\t\tvisAgent.spikeMesh.setMatrixAt( i, this.mat4 );\n\n\t\t\t}\n\t\t\t\n\t\t\tfor ( let i = 0; i < this.numBodyInstances; i++ ) {\n\n\t\t\t\tlet t = i / this.numBodyInstances;\n\t\t\t\tlet segmentI = Math.floor( t * visAgentWander.numTrailSegments );\n\t\t\t\tlet segmentT = t * visAgentWander.numTrailSegments - Math.floor( t * visAgentWander.numTrailSegments );\n\n\t\t\t\tlet bodyData = visAgent.bodyData[ i ];\n\n\t\t\t\tif ( segmentI < visAgentWander.numTrailSegments - 1 ) {\n\n\t\t\t\t\tthis.pos.copy( visAgentWander.trailSegments[ segmentI ] ).lerp( visAgentWander.trailSegments[ segmentI + 1 ], segmentT );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis.pos.copy( visAgentWander.trailSegments[ segmentI ] );\n\n\t\t\t\t}\n\n\n\t\t\t\tif ( segmentI == 0 ) {\n\n\t\t\t\t\tthis.vec2.copy( this.pos );\n\t\t\t\t\tthis.vec2.add( this.vec1.copy( visAgentWander.trailSegments[ 0 ] ).sub( visAgentWander.trailSegments[ 1 ] ).normalize() );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis.vec2.copy( this.pos );\n\t\t\t\t\tthis.vec2.add( this.vec1.copy( visAgentWander.trailSegments[ segmentI - 1 ] ).sub( visAgentWander.trailSegments[ segmentI ] ).normalize() );\n\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tlet scXY = THREE.MathUtils.smoothstep( t, 0, 0.1 ) * ( 1.0 - THREE.MathUtils.smoothstep( t, 0.9, 1.0 ) ) * 0.4;\n\t\t\t\tlet sc = Math.max( scXY + Math.sin( t * Math.PI * 2 * 30.0 + this.tick * -3.0 ) * ( scXY * 0.9 ), 0.3 );\n\t\t\t\tthis.scale.setScalar( sc );\n\n\t\t\t\tlet rndMult = Math.max ( scXY + Math.sin( t * Math.PI * 4 ) * 0.4 + Math.sin( t * Math.PI * 5 - this.tick * 4.0 ) * 0.4, 0.1 );\n\t\t\t\tthis.vec3.copy( bodyData.rnd ).multiplyScalar( rndMult );\n\t\t\t\tthis.pos.add( this.vec3 );\n\n\t\t\t\tthis.mat4.compose( this.pos, this.q1, this.scale );\n\n\t\t\t\tvisAgent.bodyMesh.setMatrixAt( i, this.mat4 );\n\n\t\t\t}\t\t\t\n\n\t\t\tvisAgent.spikeMesh.instanceMatrix.needsUpdate = true;\n\t\t\tvisAgent.bodyMesh.instanceMatrix.needsUpdate = true;\n\n\t\t}\n\t\t*/\n\t\t\n\t}\n\n\treturn vis;\n\t\n}\n\nfunction createLatticeSide( col, xDir ) {\n\t\n\tconst side = {};\n\tconst cubeW = 1.0;\n\tconst numConnections = 256;\n\t\n\tside.connectionPoints = new Float32Array( 256 * 2 * 3 );\n\tside.geo = new THREE.BufferGeometry();\n\t\n\tconst connectionSpacing = cubeW / ( numConnections / 4 );\n\t\n\tlet id = 0;\t\n\tfor ( let i = 0; i < numConnections / 4; i++ ) {\n\t\n\t\tconst x = cubeW * 0.5 * xDir;\n\t\tconst y = -cubeW * 0.5 + i * connectionSpacing;\n\t\tconst z = -cubeW * 0.5;\n\t\tside.connectionPoints[ id ] = x;\n\t\tside.connectionPoints[ id + 1 ] = y;\n\t\tside.connectionPoints[ id + 2 ] = z;\n\t\tid += 3;\n\t\tside.connectionPoints[ id ] = x;\n\t\tside.connectionPoints[ id + 1 ] = -cubeW * 0.5 + 0.2;\n\t\tside.connectionPoints[ id + 2 ] = z;\n\t\tid += 3;\n\t\t\n\t}\t\n\tfor ( let i = 0; i < numConnections / 4; i++ ) {\n\t\n\t\tconst x = cubeW * 0.5 * xDir;\n\t\tconst y = cubeW * 0.5;\n\t\tconst z = -cubeW * 0.5 + i * connectionSpacing;\n\t\tside.connectionPoints[ id ] = x;\n\t\tside.connectionPoints[ id + 1 ] = y;\n\t\tside.connectionPoints[ id + 2 ] = z;\n\t\tid += 3;\n\t\tside.connectionPoints[ id ] = x;\n\t\tside.connectionPoints[ id + 1 ] = -cubeW * 0.5 + 0.2;\n\t\tside.connectionPoints[ id + 2 ] = z;\n\t\tid += 3;\n\t\t\n\t}\t\n\tfor ( let i = 0; i < numConnections / 4; i++ ) {\n\t\n\t\tconst x = cubeW * 0.5 * xDir;\n\t\tconst y = cubeW * 0.5 - i * connectionSpacing;\n\t\tconst z = cubeW * 0.5;\n\t\tside.connectionPoints[ id ] = x;\n\t\tside.connectionPoints[ id + 1 ] = y;\n\t\tside.connectionPoints[ id + 2 ] = z;\n\t\tid += 3;\n\t\tside.connectionPoints[ id ] = x;\n\t\tside.connectionPoints[ id + 1 ] = -cubeW * 0.5 + 0.2;\n\t\tside.connectionPoints[ id + 2 ] = z;\n\t\tid += 3;\n\t\t\n\t}\t\t\n\tfor ( let i = 0; i < numConnections / 4; i++ ) {\n\t\n\t\tconst x = cubeW * 0.5 * xDir;\n\t\tconst y = -cubeW * 0.5;\n\t\tconst z = cubeW * 0.5 - i * connectionSpacing;\n\t\tside.connectionPoints[ id ] = x;\n\t\tside.connectionPoints[ id + 1 ] = y;\n\t\tside.connectionPoints[ id + 2 ] = z;\n\t\tid += 3;\n\t\tside.connectionPoints[ id ] = x;\n\t\tside.connectionPoints[ id + 1 ] = -cubeW * 0.5 + 0.2;\n\t\tside.connectionPoints[ id + 2 ] = z;\n\t\tid += 3;\n\t\t\n\t}\n\t\n\tside.geo.setAttribute( 'position', new THREE.BufferAttribute( side.connectionPoints, 3 ) );\n\t\n\tconst mat = new THREE.LineBasicMaterial( { color: col } );\n\tside.line = new THREE.LineSegments( side.geo, mat );\n\treturn side;\t\n\t\n}\n\n\n"
			}],
		"bb47580c-0ba3-4701-a8cc-a859ba88f405": [
			{
				"name": "frontBG",
				"source": "function init() {\n\n\tthis.material.uniforms = {\n\n\t\tcol1: { value: new THREE.Color( 0x281023 ) },\n\t\tcol2: { value: new THREE.Color( 0x522232 ) },\t\n\t\tcol3: { value: new THREE.Color( 0x2f2b42 ) }\t\t\n\t\t\n\t}\n\n\t/*\n\tthis.material.uniforms = {\n\n\t\tcol1: { value: new THREE.Color( 0xFF0000 ) },\n\t\tcol2: { value: new THREE.Color( 0x0000FF ) },\n\t\tcol3: { value: new THREE.Color( 0x00FF00 ) }\t\t\n\t\t\n\t}\t\n\t*/\n\t\n}"
			}]
	}
}