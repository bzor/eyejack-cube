{
	"metadata": {
		"type": "App"
	},
	"project": {
		"shadows": false,
		"shadowType": 0,
		"useLegacyLights": false,
		"toneMapping": 0,
		"toneMappingExposure": 1,
		"postprocessing": [
			{
				"type": "bloom",
				"bloomThreshold": 0.1,
				"bloomStrength": 1.7,
				"bloomRadius": 0.05,
				"exposure": 1
			}],
		"projectType": "EJXCube",
		"cubeType": "Plain",
		"faceFront": "5be9dfb5-726e-4931-8e5c-49e3b6ccb589",
		"faceRight": "4dd5b36d-97e1-445b-aebb-acc109a4329e",
		"faceBack": "5be9dfb5-726e-4931-8e5c-49e3b6ccb589",
		"faceLeft": "4dd5b36d-97e1-445b-aebb-acc109a4329e",
		"faceTop": "6ee5ad3d-e96e-49a3-984b-02a57a8501bd",
		"faceBottom": "6ee5ad3d-e96e-49a3-984b-02a57a8501bd"
	},
	"camera": {
		"metadata": {
			"version": 4.5,
			"type": "Object",
			"generator": "Object3D.toJSON"
		},
		"object": {
			"uuid": "95a6975f-e814-4802-b388-8e64d456710c",
			"type": "PerspectiveCamera",
			"name": "Camera",
			"layers": 1,
			"matrix": [0.9130176000363639,0,0.4079201662382452,0,0.13658251177053587,0.9422797701702248,-0.30570255511918215,0,-0.3843749204907739,0.3348265741065743,0.8603180143236359,0,-0.8501235874987785,0.7405373066639466,1.902768879386838,1],
			"up": [0,1,0],
			"fov": 50,
			"zoom": 1,
			"near": 0.01,
			"far": 50,
			"focus": 10,
			"aspect": 1.0160075329566856,
			"filmGauge": 35,
			"filmOffset": 0
		}
	},
	"scene": {
		"metadata": {
			"version": 4.5,
			"type": "Object",
			"generator": "Object3D.toJSON"
		},
		"geometries": [
			{
				"uuid": "78e86c2d-8bdf-4f9b-a294-54fb3c3308fe",
				"type": "BoxGeometry",
				"width": 1,
				"height": 1,
				"depth": 1,
				"widthSegments": 1,
				"heightSegments": 30,
				"depthSegments": 1
			},
			{
				"uuid": "a3bf0ef5-613e-419d-8f5a-4a0f71b04daa",
				"type": "BoxGeometry",
				"width": 1,
				"height": 1,
				"depth": 1,
				"widthSegments": 1,
				"heightSegments": 30,
				"depthSegments": 1
			}],
		"materials": [
			{
				"uuid": "39956abf-96dc-4671-9c06-34c0ef0d6a46",
				"type": "ShaderMaterial",
				"name": "frontBG",
				"side": 1,
				"depthFunc": 3,
				"depthTest": true,
				"depthWrite": true,
				"colorWrite": true,
				"stencilWrite": false,
				"stencilWriteMask": 255,
				"stencilFunc": 519,
				"stencilRef": 0,
				"stencilFuncMask": 255,
				"stencilFail": 7680,
				"stencilZFail": 7680,
				"stencilZPass": 7680,
				"forceSinglePass": true,
				"fog": false,
				"glslVersion": null,
				"uniforms": {},
				"vertexShader": "\nuniform vec3 colFront1;\nuniform vec3 colFront2;\nuniform vec3 colFront3;\nuniform vec3 colBack1;\nuniform vec3 colBack2;\nuniform vec3 colBack3;\nuniform vec3 groupPos;\nuniform vec3 groupDir;\nvarying vec4 vCol;\n\nvoid main() {\n\n\tvec4 pos = vec4( position, 1.0 );\n\tvec4 worldPos = modelMatrix * pos;\n\tvec4 viewPos = viewMatrix * worldPos;\n\n\tvec4 vCol1 = mix( vec4( colFront1, 1.0 ), vec4( colFront2, 1.0 ), clamp( worldPos.y, -2.0, 0.0 ) + 0.5 ) ;\n\tvCol1 = mix( vCol1, vec4( colFront3, 1.0 ), smoothstep( 0.0, 1.5, worldPos.y ) ) ;\n\n\tvec4 vCol2 = mix( vec4( colBack1, 1.0 ), vec4( colBack2, 1.0 ), smoothstep( -1.5, -0.5, worldPos.y ) ) ;\n\tvCol2 = mix( vCol2, vec4( colBack3, 1.0 ), smoothstep( -0.5, 0.75, worldPos.y ) ) ;\n\t\n\tfloat dir = dot ( cameraPosition - groupPos, groupDir );\n\t\n\t//vCol1 = vec4( 1.0, 0.0, 0.0, 1.0 );\n\t//vCol2 = vec4( 0.0, 0.0, 1.0, 1.0 );\n\tvCol = mix( vCol1, vCol2, smoothstep( -0.01, 0.01, dir ) );\n\n\tgl_Position = projectionMatrix * viewPos;\n\t\n}\n\n",
				"fragmentShader": "#define PI 3.141592653589793\nvarying vec4 vCol;\n\nhighp float rand( const in vec2 uv ) {\n  const highp float a = 12.9898, b = 78.233, c = 43758.5453;\n  highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n  return fract( sin( sn ) * c );\n}\n\nvec3 dithering( vec3 color ) {\n  float grid_position = rand( gl_FragCoord.xy );\n  vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n  dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n  return color + dither_shift_RGB;\n}\n\nvoid main() {\n\t\n\tgl_FragColor = vCol;\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n\t\n}"
			},
			{
				"uuid": "2a30ac58-b6b7-477a-b745-e1be5590baef",
				"type": "ShaderMaterial",
				"name": "leftBG",
				"side": 1,
				"depthFunc": 3,
				"depthTest": true,
				"depthWrite": true,
				"colorWrite": true,
				"stencilWrite": false,
				"stencilWriteMask": 255,
				"stencilFunc": 519,
				"stencilRef": 0,
				"stencilFuncMask": 255,
				"stencilFail": 7680,
				"stencilZFail": 7680,
				"stencilZPass": 7680,
				"forceSinglePass": true,
				"fog": false,
				"glslVersion": null,
				"uniforms": {},
				"vertexShader": "\nuniform vec3 colFront1;\nuniform vec3 colFront2;\nuniform vec3 colFront3;\nuniform vec3 colBack1;\nuniform vec3 colBack2;\nuniform vec3 colBack3;\nuniform vec3 groupPos;\nuniform vec3 groupDir;\nvarying vec4 vCol;\n\nvoid main() {\n\n\tvec4 pos = vec4( position, 1.0 );\n\tvec4 worldPos = modelMatrix * pos;\n\tvec4 viewPos = viewMatrix * worldPos;\n\n\tvec4 vCol1 = mix( vec4( colFront1, 1.0 ), vec4( colFront2, 1.0 ), smoothstep( -1.0, 0.0, worldPos.y ) ) ;\n\tvCol1 = mix( vCol1, vec4( colFront3, 1.0 ), smoothstep( 0.0, 1.0, worldPos.y ) ) ;\n\n\tvec4 vCol2 = mix( vec4( colBack1, 1.0 ), vec4( colBack2, 1.0 ), smoothstep( -1.2, 0.0, worldPos.y ) ) ;\n\tvCol2 = mix( vCol2, vec4( colBack3, 1.0 ), smoothstep( 0.0, 1.2, worldPos.y ) ) ;\n\t\n\tfloat dir = dot ( cameraPosition - groupPos, groupDir );\n\t\n\t//vCol1 = vec4( 1.0, 0.0, 0.0, 1.0 );\n\t//vCol2 = vec4( 0.0, 0.0, 1.0, 1.0 );\n\tvCol = mix( vCol1, vCol2, smoothstep( -0.01, 0.01, dir ) );\n\n\tgl_Position = projectionMatrix * viewPos;\n\t\n}\n\n",
				"fragmentShader": "#define PI 3.141592653589793\nvarying vec4 vCol;\n\nhighp float rand( const in vec2 uv ) {\n  const highp float a = 12.9898, b = 78.233, c = 43758.5453;\n  highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n  return fract( sin( sn ) * c );\n}\n\nvec3 dithering( vec3 color ) {\n  float grid_position = rand( gl_FragCoord.xy );\n  vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n  dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n  return color + dither_shift_RGB;\n}\n\nvoid main() {\n\t\n\tgl_FragColor = vCol;\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n\t\n}"
			}],
		"object": {
			"uuid": "31517222-A9A7-4EAF-B5F6-60751C0BABA3",
			"type": "Scene",
			"name": "Scene",
			"layers": 1,
			"matrix": [1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],
			"up": [0,1,0],
			"children": [
				{
					"uuid": "6ee5ad3d-e96e-49a3-984b-02a57a8501bd",
					"type": "Group",
					"name": "faceTop",
					"layers": 1,
					"matrix": [1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],
					"up": [0,1,0]
				},
				{
					"uuid": "5be9dfb5-726e-4931-8e5c-49e3b6ccb589",
					"type": "Group",
					"name": "faceFront",
					"layers": 1,
					"matrix": [1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],
					"up": [0,1,0],
					"children": [
						{
							"uuid": "bb47580c-0ba3-4701-a8cc-a859ba88f405",
							"type": "Mesh",
							"name": "frontBackEnv",
							"layers": 1,
							"matrix": [3,0,0,0,0,3,0,0,0,0,3,0,0,0,0,1],
							"up": [0,1,0],
							"geometry": "78e86c2d-8bdf-4f9b-a294-54fb3c3308fe",
							"material": "39956abf-96dc-4671-9c06-34c0ef0d6a46"
						}]
				},
				{
					"uuid": "4dd5b36d-97e1-445b-aebb-acc109a4329e",
					"type": "Group",
					"name": "faceLeft",
					"layers": 1,
					"matrix": [1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],
					"up": [0,1,0],
					"children": [
						{
							"uuid": "6499bc57-679f-4a63-bf90-d2b45c5834f9",
							"type": "Mesh",
							"name": "leftRightEnv",
							"layers": 1,
							"matrix": [6.661338147750939e-16,0,-3,0,0,3,0,0,3,0,6.661338147750939e-16,0,0,0,0,1],
							"up": [0,1,0],
							"geometry": "a3bf0ef5-613e-419d-8f5a-4a0f71b04daa",
							"material": "2a30ac58-b6b7-477a-b745-e1be5590baef"
						}]
				}]
		}
	},
	"scripts": {
		"31517222-A9A7-4EAF-B5F6-60751C0BABA3": [
			{
				"name": "main",
				"source": "//wander settings\nconst wanderSettings = {};\nwanderSettings.boundingSphereRadius = 0.5;\nwanderSettings.boundingForceMult = 1;\nwanderSettings.wanderSphereDistance = 0.1;\nwanderSettings.wanderSphereRadius = 8;\nwanderSettings.wanderAngleMaxChange = 12;\nwanderSettings.wanderBoundsAngleMaxChange = 8;\nwanderSettings.maxVelocity = 0.008;\nwanderSettings.maxSteeringForce = 8;\nwanderSettings.trailAvoidDist = 0.04;\nwanderSettings.trailDropDelay = 0.015;\nwanderSettings.numTrailSegments = 256;\nwanderSettings.dustAvoidDist = 0.04;\n\nconst agents = [];\nconst agentVizs = [];\n\nlet dust;\nconst numDust = 4096;\n\nlet faceFront;\nlet faceFrontEnv;\nconst frontPos = new THREE.Vector3();\nconst frontDir = new THREE.Vector3();\nlet faceLeft;\nlet faceLeftEnv;\nconst leftPos = new THREE.Vector3();\nconst leftDir = new THREE.Vector3();\nlet faceTop;\n\nfunction init() {\n\n\tconsole.log(\"init main\");\n\tlet agentData1 = { wander: createWander(this), id: 0 };\n\tagents.push(agentData1);\n\tlet agentData2 = { wander: createWander(this), id: 1 };\n\tagents.push(agentData2);\n\n\tfaceFront = this.getObjectByName(\"faceFront\");\n\tfaceFrontEnv = faceFront.getObjectByName(\"frontBackEnv\");\n\tfaceFrontEnv.getWorldPosition( frontPos );\n\tfaceFrontEnv.getWorldDirection( frontDir );\n\tfaceLeft = this.getObjectByName(\"faceLeft\");\n\tfaceLeftEnv = faceLeft.getObjectByName(\"leftRightEnv\");\n\tfaceLeftEnv.getWorldPosition( leftPos );\n\tfaceLeftEnv.getWorldDirection( leftDir );\n\tfaceTop = this.getObjectByName(\"faceTop\");\n\t\n\tagentVizs.push(vis1(faceFront));\n\tagentVizs.push(vis2(faceLeft));\n\tagentVizs.push(vis3(faceTop));\n\n\tdust = createDust();\n\tfaceFront.add(dust.meshFront);\n\tfaceLeft.add(dust.meshLeft);\n\tfaceTop.add(dust.meshTop);\n\n}\n\nfunction update(event) {\n\n\tconst deltaTime = event.delta * 0.001;\n\tconst time = event.time;\n\n\tfaceFrontEnv.getWorldPosition( frontPos );\n\tfaceFrontEnv.getWorldDirection( frontDir );\t\n\tfaceLeftEnv.getWorldPosition( leftPos );\n\tfaceLeftEnv.getWorldDirection( leftDir );\t\n\t\n\tfor (let i = 0; i < agents.length; i++) {\n\n\t\tupdateAgent(agents[i], deltaTime);\n\n\t}\n\n\tfor (let i = 0; i < agentVizs.length; i++) {\n\n\t\tagentVizs[i].update(deltaTime, time);\n\n\t}\n\n\tupdateDust(deltaTime);\n\n}\n\n//\n//agents\n//\n\nfunction updateAgent(agentData, deltaTime) {\n\n\tconst wander = agentData.wander;\n\n\twander.agentLookat.position.copy(wander.agentPoint);\n\n\twander.vec1.copy(wander.agentPoint);\n\n\tlet distanceFromCenter = wander.vec1.sub(wander.centerPoint).length();\n\tif (distanceFromCenter > wanderSettings.boundingSphereRadius) {\n\n\t\twander.agentLookat.lookAt(wander.centerPoint);\n\t\twander.wanderAngle.rotateTowards(wander.agentLookat.quaternion, wanderSettings.wanderBoundsAngleMaxChange * deltaTime);\n\n\t} else {\n\n\t\twander.boundingForce.setScalar(0);\n\n\t}\n\n\t//attract heads\n\twander.trailAvoidForce.setScalar(0);\n\tfor (let i = 0; i < agents.length; i++) {\n\n\t\tlet agent = agents[i];\n\t\tif (agent.wander == wander) {\n\n\t\t\tcontinue;\n\n\t\t}\n\n\t\tlet attactMult = 3;\n\t\twander.vec1.copy(agent.wander.agentPoint).sub(wander.agentPoint).normalize().multiplyScalar(attactMult);\n\t\twander.trailAvoidForce.add(wander.vec1);\n\n\t}\n\n\t//avoid trails\n\tfor (let i = 0; i < agents.length; i++) {\n\n\t\tlet agent = agents[i];\n\n\t\tlet jStart = (i == agents[i].id) ? Math.floor(wanderSettings.numTrailSegments) * 0.5 : 0;\n\n\t\tfor (let j = 0; j < wanderSettings.numTrailSegments; j++) {\n\n\t\t\twander.vec1.copy(agent.wander.trailSegments[j]);\n\t\t\tlet dist = wander.vec1.distanceToSquared(wander.agentPoint);\n\t\t\tif (dist < wanderSettings.trailAvoidDist) {\n\n\t\t\t\tlet forceMult = (wanderSettings.trailAvoidDist - dist) * 50.0;\n\t\t\t\twander.vec1.copy(wander.agentPoint).sub(agent.wander.trailSegments[j]).normalize().multiplyScalar(forceMult);\n\t\t\t\twander.trailAvoidForce.add(wander.vec1);\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\twander.wanderSphereCenter.copy(wander.currentVelocity).normalize().multiplyScalar(wanderSettings.wanderSphereDistance);\n\twander.q1.random();\n\twander.wanderAngle.rotateTowards(wander.q1, wanderSettings.wanderAngleMaxChange * deltaTime);\n\twander.wanderForce.setScalar(0);\n\twander.wanderDir.copy(wander.forward).applyQuaternion(wander.wanderAngle).multiplyScalar(wanderSettings.wanderSphereRadius);\n\twander.wanderForce.copy(wander.wanderSphereCenter).add(wander.wanderDir);\n\twander.wanderForce.clampLength(0, wanderSettings.maxSteeringForce);\n\n\twander.wanderForce.add(wander.trailAvoidForce);\n\twander.vec1.copy(wander.wanderForce).multiplyScalar(deltaTime);\n\twander.currentVelocity.add(wander.vec1);\n\twander.vec1.copy(wander.boundingForce).multiplyScalar(deltaTime);\n\twander.currentVelocity.add(wander.vec1);\n\twander.currentVelocity.clampLength(0, wanderSettings.maxVelocity);\n\n\twander.agentPoint.add(wander.currentVelocity);\n\n\twander.trailDropTick += deltaTime;\n\tif (wander.trailDropTick > wanderSettings.trailDropDelay) {\n\n\t\twander.trailDropTick = 0;\n\n\t\tfor (let i = wanderSettings.numTrailSegments - 1; i > 0; i--) {\n\n\t\t\twander.trailSegments[i].copy(wander.trailSegments[i - 1]);\n\n\t\t}\n\t\twander.trailSegments[0].copy(wander.agentPoint);\n\n\t}\n\n}\n\nfunction createWander(scene) {\n\n\tconst wander = {};\n\n\twander.vec1 = new THREE.Vector3();\n\twander.vec2 = new THREE.Vector3();\n\twander.vec3 = new THREE.Vector3();\n\twander.vec4 = new THREE.Vector3();\n\twander.q1 = new THREE.Quaternion();\n\twander.forward = new THREE.Vector3(0, 0, 1.0);\n\n\twander.agentPoint = new THREE.Vector3(0.05, 0.05, 0.05);\n\twander.agentLookat = new THREE.Object3D();\n\n\twander.currentPosition = new THREE.Vector3();\n\n\twander.centerPoint = new THREE.Vector3();\n\n\twander.currentVelocity = new THREE.Vector3().randomDirection().multiplyScalar(wanderSettings.maxVelocity);\n\twander.maxVelocitySq = wanderSettings.maxVelocity * wanderSettings.maxVelocity;\n\n\twander.boundingForce = new THREE.Vector3();\n\n\twander.wanderAngle = new THREE.Quaternion().random();\n\twander.wanderSphereCenter = new THREE.Vector3();\n\twander.wanderForce = new THREE.Vector3();\n\twander.wanderDir = new THREE.Vector3();\n\n\twander.trailAvoidDist = wanderSettings.trailAvoidDist * wanderSettings.trailAvoidDist;\n\twander.trailAvoidForce = new THREE.Vector3();\n\twander.trailDropTick = 0;\n\twander.numTrailSegments = wanderSettings.numTrailSegments;\n\twander.trailSegments = [];\n\tfor (let i = 0; i < wanderSettings.numTrailSegments; i++) {\n\n\t\twander.trailSegments.push(new THREE.Vector3());\n\n\t}\n\n\treturn wander;\n\n}\n\n//\n//dust\n//\n\nconst dustVert = `\n\nattribute vec3 iPos;\nuniform vec3 col;\nvarying vec3 vCol;\n\nvoid main() {\n\t\n\tvCol = col;\n\tvec4 mvPos = modelViewMatrix * vec4( iPos, 1.0 );\n\tmvPos.xyz += position;\n\tgl_Position = projectionMatrix * mvPos;\n\n}\n`;\n\nconst dustFrag = `\n\nvarying vec3 vCol;\n\nvoid main() {\n\n\tvec4 col = vec4( vCol, 1.0 );\n    gl_FragColor = col;\n\n}\n`;\n\nfunction createDust() {\n\n\tconst dust = {};\n\tconst points = new Float32Array(numDust * 3);\n\tconst velocities = [];\n\tlet v = new THREE.Vector3();\n\tfor (let i = 0; i < numDust; i++) {\n\n\t\tlet x = THREE.MathUtils.randFloatSpread(1.0);\n\t\tlet y = THREE.MathUtils.randFloatSpread(1.0);\n\t\tlet z = THREE.MathUtils.randFloatSpread(1.0);\n\n\t\tpoints[i * 3] = x;\n\t\tpoints[i * 3 + 1] = y;\n\t\tpoints[i * 3 + 2] = z;\n\n\t\tv.randomDirection().multiplyScalar(0.02);\n\t\tvelocities.push(v.clone());\n\n\t}\n\n\tconst mat = new THREE.ShaderMaterial({ uniforms: { col: { value: new THREE.Color(0x222222) }, pixelRatio: { value: window.devicePixelRatio } }, vertexShader: dustVert, fragmentShader: dustFrag });\n\tmat.blending = THREE.AdditiveBlending;\n\n\tconst dustGeo = new THREE.CircleGeometry(0.0025, 6);\n\n\tconst pointBuffer = new THREE.InstancedBufferAttribute(points, 3);\n\tpointBuffer.setUsage( THREE.StreamDrawUsage );\n\tdustGeo.setAttribute('iPos', pointBuffer);\n\n\tconst dustMeshFront = new THREE.InstancedMesh(dustGeo, mat, numDust);\n\tconst dustMeshLeft = new THREE.InstancedMesh(dustGeo, mat, numDust);\n\tconst dustMeshTop = new THREE.InstancedMesh(dustGeo, mat, numDust);\n\n\tdust.meshFront = dustMeshFront;\n\tdust.meshLeft = dustMeshLeft;\n\tdust.meshTop = dustMeshTop;\n\tdust.geo = dustGeo;\n\tdust.mat = mat;\n\tdust.velocities = velocities;\n\tdust.pos = new THREE.Vector3();\n\tdust.vec1 = new THREE.Vector3();\n\tdust.moveForce = new THREE.Vector3();\n\n\treturn dust;\n\n}\n\nfunction updateDust(deltaTime) {\n\n\tconst posAttribute = dust.geo.getAttribute(\"iPos\");\n\tconst border = 0.5;\n\n\tfor (let i = 0; i < numDust; i++) {\n\n\t\tlet x = posAttribute.array[i * 3];\n\t\tlet y = posAttribute.array[i * 3 + 1];\n\t\tlet z = posAttribute.array[i * 3 + 2];\n\n\t\tlet v = dust.velocities[i];\n\n\t\tif (x < -border) {\n\n\t\t\tv.x = Math.abs(v.x);\n\n\t\t} else if (x > border) {\n\n\t\t\tv.x = -Math.abs(v.x);\n\n\t\t}\n\n\t\tif (y < -border) {\n\n\t\t\tv.y = Math.abs(v.y);\n\n\t\t} else if (y > border) {\n\n\t\t\tv.y = -Math.abs(v.y);\n\n\t\t}\n\n\t\tif (z < -border) {\n\n\t\t\tv.z = Math.abs(v.z);\n\n\t\t} else if (z > border) {\n\n\t\t\tv.z = -Math.abs(v.z);\n\n\t\t}\n\n\t\tdust.moveForce.set(0.0, 0.0, 0.0);\n\t\tfor (let i = 0; i < agents.length; i++) {\n\n\t\t\tlet agent = agents[i];\n\n\t\t\tfor (let j = 0; j < wanderSettings.numTrailSegments; j++) {\n\n\t\t\t\tdust.pos.set(x, y, z);\n\t\t\t\tdust.vec1.copy(agent.wander.trailSegments[j]);\n\t\t\t\tlet dist = dust.vec1.distanceToSquared(dust.pos);\n\t\t\t\tif (dist < wanderSettings.dustAvoidDist) {\n\n\t\t\t\t\tlet forceMult = (wanderSettings.dustAvoidDist - dist) * 0.4;\n\t\t\t\t\tdust.vec1.copy(dust.pos).sub(agent.wander.trailSegments[j]).normalize().multiplyScalar(forceMult);\n\t\t\t\t\tdust.moveForce.add(dust.vec1);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tdust.vec1.copy(v).add(dust.moveForce);\n\n\t\tx += dust.vec1.x * deltaTime;\n\t\ty += dust.vec1.y * deltaTime;\n\t\tz += dust.vec1.z * deltaTime;\n\t\tposAttribute.setXYZ(i, x, y, z);\n\n\t}\n\tposAttribute.needsUpdate = true;\n\n}\n\n//\n//vis1 - front/back\n//\n\nconst vis1SpikeVert = `\n\nuniform vec3 col1;\nuniform vec3 col2_1;\nuniform vec3 col2_2;\nvarying vec3 vCol;\nuniform vec3 groupPos;\nuniform vec3 groupDir;\n\nvoid main() {\n\n\tvec4 vPos = vec4( position, 1.0 );\n    vec4 iPos = instanceMatrix * vPos;\n    vec4 worldPos = modelMatrix * iPos;\n    vec4 viewPos = viewMatrix * worldPos;\n\n\tfloat dir = dot ( cameraPosition - groupPos, groupDir );\n\tfloat dirT = smoothstep( -0.01, 0.01, dir );\n\n\tvec3 vCol1 = col1;\n\tvec3 vCol2 = mix( col2_1, col2_2, smoothstep( -0.1, 0.1, iPos.y ) );\n\t\n\tvCol = mix( vCol1, vCol2, dirT ) * smoothstep( 0.05, 0.09, vPos.y );\n\t\n\t\n    gl_Position = projectionMatrix * viewPos;\n\n}\n`;\n\nconst vis1SpikeFrag = `\n\nuniform float uTime;\nvarying vec3 vCol;\n\nvoid main() {\n\n    gl_FragColor = vec4( vCol, 1.0 );\n\n}\n`;\n\nconst vis1BodyVert = `\n\n#define PI 3.141592653589793\nattribute vec3 iPos;\nattribute vec3 rndPos;\nattribute vec3 dir;\nattribute float t;\nuniform vec3 col1;\nuniform vec3 col2;\nuniform float uTime;\nvarying vec3 vCol;\n\nvoid main() {\n\t\n\tfloat scXY = smoothstep( 0.0, 0.1, t ) * ( 1.0 - smoothstep( 0.9, 1.0, t ) ) * 0.2;\n\tfloat sc = max( scXY + sin( t * PI * 2.0 * 30.0 + uTime * -3.0 ) * scXY, 0.3 );\n\tfloat rndMult = max ( scXY + sin( t * PI * 4.0 ) * 0.4 + sin( t * PI * 5.0 - uTime * 4.0 ) * 0.4, 0.1 );\n\n\tvec3 pos = position;\n\tpos *= sc;\n\n\tvec3 vPos = pos + rndPos * rndMult;\n\n\tvec4 mvPos = modelViewMatrix * vec4( iPos, 1.0 );\n\tmvPos.xyz += vPos;\n\tgl_Position = projectionMatrix * mvPos;\n\t\n\tvec3 worldPos = ( modelMatrix * vec4( iPos, 1.0 ) ).xyz;\n\tvCol = mix( col1, col2, smoothstep( -0.5, 0.5, dot( cameraPosition - worldPos, dir ) ) );\n\n}\n`;\n\nconst vis1BodyFrag = `\n\nuniform float uTime;\n\nvarying vec3 vCol;\n\nvoid main() {\n\n    gl_FragColor = vec4( vCol, 1.0 );\n\n}\n`;\n\n\n\nfunction vis1(faceGroup) {\n\n\t//vis\n\tconst vis = {};\n\n\tvis.spineElemR = 0.01;\n\tvis.spineElemH = 0.04;\n\tvis.bodyElemScale = 0.02;\n\tvis.numSpineInstances = 1024;\n\tvis.numBodyInstances = 512;\n\tvis.numSpineLoops = 323;\n\tvis.visAgents = [];\n\tvis.cols1 = [0xdf4266, 0xd246d8];\n\tvis.cols2 = [ 0x44bfd9, 0xd743cb];\n\tvis.bodyCols = [0x43adc8, 0xc84f43];\n\n\tvis.pos = new THREE.Vector3();\n\tvis.vec1 = new THREE.Vector3();\n\tvis.vec2 = new THREE.Vector3();\n\tvis.vec3 = new THREE.Vector3();\n\tvis.mat3 = new THREE.Matrix3();\n\tvis.mat4 = new THREE.Matrix4();\n\tvis.matRot4 = new THREE.Matrix4();\n\tvis.q1 = new THREE.Quaternion();\n\tvis.q2 = new THREE.Quaternion();\n\tvis.q3 = new THREE.Quaternion();\n\tvis.scale = new THREE.Vector3();\n\tvis.forward = new THREE.Vector3(0, 0, 1.0);\n\tvis.up = new THREE.Vector3(0, 1.0, 0);\n\n\tvis.tick = 0;\n\n\tvis.faceGroup = faceGroup;\t\n\n\tfor (let i = 0; i < agents.length; i++) {\n\n\t\tconst geo = new THREE.ConeGeometry(vis.spineElemR, vis.spineElemH, 5, 1);\n\t\tgeo.translate(0, vis.spineElemH * 0.5 + 0.05, 0);\n\n\t\tconst spikeUniforms = {\n\t\t\t\"col1\": { value: new THREE.Color(vis.cols1[i]) },\n\t\t\t\"col2_1\": { value: new THREE.Color(vis.cols2[i] ) },\n\t\t\t\"col2_2\": { value: new THREE.Color(vis.cols2[1 - i]) },\n\t\t\t\"groupPos\": { value: frontPos },\n\t\t\t\"groupDir\": { value: frontDir }\n\n\t\t\t\n\t\t};\n\t\tconst spikeMat = new THREE.ShaderMaterial({ uniforms: spikeUniforms, vertexShader: vis1SpikeVert, fragmentShader: vis1SpikeFrag });\n\t\t//mat.blending = THREE.AdditiveBlending;\n\t\t//const mat = new THREE.MeshBasicMaterial( { color: vis.cols[ i ] } );\n\t\t\n\t\tconst spikeMesh = new THREE.InstancedMesh(geo, spikeMat, vis.numSpineInstances);\n\t\tspikeMesh.instanceMatrix.setUsage(THREE.StreamDrawUsage);\n\t\tfaceGroup.add(spikeMesh);\n\n\t\tconst bodyUniforms = {\n\t\t\t\"col1\": { value: new THREE.Color(vis.bodyCols[i]) },\n\t\t\t\"col2\": { value: new THREE.Color(vis.bodyCols[1 - i]) },\n\t\t\t\"uTime\": { value: 0 }\n\t\t};\n\t\tconst bodyMat = new THREE.ShaderMaterial({ uniforms: bodyUniforms, vertexShader: vis1BodyVert, fragmentShader: vis1BodyFrag });\n\t\tbodyMat.blending = THREE.AdditiveBlending;\n\n\t\t//const bodyGeo = new THREE.IcosahedronGeometry( vis.bodyElemScale, 0 );\n\t\tconst bodyGeo = new THREE.CircleGeometry(vis.bodyElemScale, 8);\n\t\tconst bodyMesh = new THREE.InstancedMesh(bodyGeo, bodyMat, vis.numBodyInstances);\n\t\tfaceGroup.add(bodyMesh);\n\n\t\tconst agentData = { agent: agents[i], spikeMesh: spikeMesh, bodyMesh: bodyMesh, spikeUniforms: spikeUniforms, bodyUniforms: bodyUniforms, spikeData: [] };\n\n\t\tfor (let i = 0; i < vis.numSpineInstances; i++) {\n\n\t\t\tagentData.spikeData.push({ q: new THREE.Quaternion() });\n\n\t\t}\n\n\t\tconst bodyDirs = new Float32Array(vis.numBodyInstances * 3);\n\t\tconst bodyIPos = new Float32Array(vis.numBodyInstances * 3);\n\t\tconst bodyRndPos = new Float32Array(vis.numBodyInstances * 3);\n\t\tconst bodyT = new Float32Array(vis.numBodyInstances);\n\t\tfor (let i = 0; i < vis.numBodyInstances; i++) {\n\n\t\t\tlet rnd = new THREE.Vector3().randomDirection().multiplyScalar(0.05);\n\t\t\tbodyRndPos[i * 3] = rnd.x;\n\t\t\tbodyRndPos[i * 3 + 1] = rnd.y;\n\t\t\tbodyRndPos[i * 3 + 2] = rnd.z;\n\t\t\tbodyDirs[i * 3] = 0;\n\t\t\tbodyDirs[i * 3 + 1] = 0;\n\t\t\tbodyDirs[i * 3 + 2] = 0;\n\n\t\t\tbodyT[i] = i / (vis.numBodyInstances - 1);\n\n\t\t}\n\n\t\tconst bodyIposBuffer = new THREE.InstancedBufferAttribute(bodyIPos, 3);\n\t\tbodyIposBuffer.setUsage(THREE.StreamDrawUsage);\n\t\tbodyGeo.setAttribute('iPos', bodyIposBuffer);\n\t\tconst bodyDirsBuffer = new THREE.InstancedBufferAttribute(bodyDirs, 3);\n\t\tbodyDirsBuffer.setUsage(THREE.StreamDrawUsage);\n\t\tbodyGeo.setAttribute('dir', bodyDirsBuffer);\n\t\tbodyGeo.setAttribute('rndPos', new THREE.InstancedBufferAttribute(bodyRndPos, 3));\n\t\tbodyGeo.setAttribute('t', new THREE.InstancedBufferAttribute(bodyT, 1));\n\n\t\tvis.visAgents.push(agentData);\n\n\t}\n\n\tvis.update = function (deltaTime, time) {\n\n\t\tthis.tick += deltaTime;\n\n\t\tlet visAgent, visAgentWander;\n\t\tfor (let j = 0; j < vis.visAgents.length; j++) {\n\n\t\t\tvisAgent = this.visAgents[j];\n\t\t\tvisAgentWander = visAgent.agent.wander;\n\t\t\tvisAgent.bodyUniforms.uTime.value = this.tick;\n\t\t\tvisAgent.spikeUniforms.groupPos.value = frontPos;\n\t\t\tvisAgent.spikeUniforms.groupDir.value = frontDir;\n\n\t\t\tfor (let i = 0; i < this.numSpineInstances; i++) {\n\n\t\t\t\tlet t = i / this.numSpineInstances;\n\t\t\t\tlet segmentI = Math.floor(t * visAgentWander.numTrailSegments);\n\t\t\t\tlet segmentT = t * visAgentWander.numTrailSegments - Math.floor(t * visAgentWander.numTrailSegments);\n\t\t\t\tlet spikeData = visAgent.spikeData[i];\n\n\t\t\t\tif (segmentI < visAgentWander.numTrailSegments - 1) {\n\n\t\t\t\t\tthis.pos.copy(visAgentWander.trailSegments[segmentI]).lerp(visAgentWander.trailSegments[segmentI + 1], segmentT);\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis.pos.copy(visAgentWander.trailSegments[segmentI]);\n\n\t\t\t\t}\n\n\n\t\t\t\tif (segmentI == 0) {\n\n\t\t\t\t\tthis.vec2.copy(this.pos);\n\t\t\t\t\tthis.vec2.add(this.vec1.copy(visAgentWander.trailSegments[0]).sub(visAgentWander.trailSegments[1]).normalize());\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis.vec2.copy(this.pos);\n\t\t\t\t\tthis.vec2.add(this.vec1.copy(visAgentWander.trailSegments[segmentI - 1]).sub(visAgentWander.trailSegments[segmentI]).normalize());\n\n\t\t\t\t}\n\n\t\t\t\tthis.matRot4.lookAt(this.pos, this.vec2, this.up);\n\t\t\t\tthis.q1.setFromRotationMatrix(this.matRot4);\n\n\t\t\t\tthis.q2.setFromAxisAngle(this.forward, t * Math.PI * 2 * this.numSpineLoops + this.tick * 1.0);\n\t\t\t\tthis.q1.multiply(this.q2);\n\n\t\t\t\tspikeData.q.slerp(this.q1, deltaTime * 2.0);\n\n\t\t\t\tlet scXY = THREE.MathUtils.smoothstep(t, 0, 0.1) * (1.0 - THREE.MathUtils.smoothstep(t, 0.9, 1.0)) * 1.0;\n\t\t\t\tlet sc = Math.max(scXY + Math.sin(t * Math.PI * 2 * 30.0 + this.tick * -3.0) * (scXY * 0.9), 0.3);\n\t\t\t\tsc = scXY;\n\t\t\t\tthis.scale.setScalar(sc);\n\n\t\t\t\tlet rndMult = Math.max(scXY + Math.sin(t * Math.PI * 4) * 0.4 + Math.sin(t * Math.PI * 5 - this.tick * 4.0) * 0.4, 0.1);\n\n\t\t\t\tthis.mat4.compose(this.pos, spikeData.q, this.scale);\n\n\t\t\t\tvisAgent.spikeMesh.setMatrixAt(i, this.mat4);\n\n\t\t\t}\n\n\n\t\t\tlet bodyDirs = visAgent.bodyMesh.geometry.getAttribute(\"dir\");\n\t\t\tlet bodyIPos = visAgent.bodyMesh.geometry.getAttribute(\"iPos\");\n\n\t\t\tfor (let i = 0; i < this.numBodyInstances; i++) {\n\n\t\t\t\tlet t = i / this.numBodyInstances;\n\t\t\t\tlet segmentI = Math.floor(t * visAgentWander.numTrailSegments);\n\t\t\t\tlet segmentT = t * visAgentWander.numTrailSegments - Math.floor(t * visAgentWander.numTrailSegments);\n\n\t\t\t\tif (segmentI < visAgentWander.numTrailSegments - 1) {\n\n\t\t\t\t\tthis.pos.copy(visAgentWander.trailSegments[segmentI]).lerp(visAgentWander.trailSegments[segmentI + 1], segmentT);\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis.pos.copy(visAgentWander.trailSegments[segmentI]);\n\n\t\t\t\t}\n\n\n\t\t\t\tif (segmentI == 0) {\n\n\t\t\t\t\tthis.vec2.copy(this.pos);\n\t\t\t\t\tthis.vec2.add(this.vec1.copy(visAgentWander.trailSegments[0]).sub(visAgentWander.trailSegments[1]).normalize());\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis.vec2.copy(this.pos);\n\t\t\t\t\tthis.vec2.add(this.vec1.copy(visAgentWander.trailSegments[segmentI - 1]).sub(visAgentWander.trailSegments[segmentI]).normalize());\n\n\t\t\t\t}\n\n\t\t\t\tbodyDirs.setXYZ(i, this.vec2.x, this.vec2.y, this.vec2.z);\n\t\t\t\tbodyIPos.setXYZ(i, this.pos.x, this.pos.y, this.pos.z);\n\n\t\t\t}\n\n\t\t\tvisAgent.spikeMesh.instanceMatrix.needsUpdate = true;\n\t\t\tbodyDirs.needsUpdate = true;\n\t\t\tbodyIPos.needsUpdate = true;\n\n\t\t}\n\n\t}\n\n\treturn vis;\n\n}\n\n//\n//vis2 - left/right\n//\n\nconst vis2SpikeVert = `\n\nuniform vec3 col1;\nuniform vec3 col2_1;\nuniform vec3 col2_2;\nvarying vec3 vCol;\nuniform vec3 groupPos;\nuniform vec3 groupDir;\n\nvoid main() {\n\n\tvec4 vPos = vec4( position, 1.0 );\n    vec4 iPos = instanceMatrix * vPos;\n    vec4 worldPos = modelMatrix * iPos;\n    vec4 viewPos = viewMatrix * worldPos;\n\n\tfloat dir = dot ( cameraPosition - groupPos, groupDir );\n\tfloat dirT = smoothstep( -0.01, 0.01, dir );\n\n\tvec3 vCol1 = col1;\n\tvec3 vCol2 = mix( col2_1, col2_2, smoothstep( -0.2, 0.2, iPos.y ) );\n\t\n\tvCol = mix( vCol1, vCol2, dirT ) * smoothstep( 0.05, 0.09, vPos.y );\n\t\n\t\n    gl_Position = projectionMatrix * viewPos;\n\n}\n`;\n\nconst vis2SpikeFrag = `\n\nuniform float uTime;\nvarying vec3 vCol;\n\nvoid main() {\n\n    gl_FragColor = vec4( vCol, 1.0 );\n\n}\n`;\n\nconst vis2BodyVert = `\n\n#define PI 3.141592653589793\nattribute vec3 iPos;\nattribute vec3 rndPos;\nattribute vec3 dir;\nattribute float t;\nuniform vec3 col1;\nuniform vec3 col2;\nuniform float uTime;\nvarying vec3 vCol;\n\nvoid main() {\n\t\n\tfloat scXY = smoothstep( 0.0, 0.1, t ) * ( 1.0 - smoothstep( 0.9, 1.0, t ) ) * 0.2;\n\tfloat sc = max( scXY + sin( t * PI * 2.0 * 30.0 + uTime * -3.0 ) * scXY, 0.3 );\n\tfloat rndMult = max ( scXY + sin( t * PI * 4.0 ) * 0.4 + sin( t * PI * 5.0 - uTime * 4.0 ) * 0.4, 0.1 );\n\n\tvec3 pos = position;\n\tpos *= sc;\n\n\tvec3 vPos = pos + rndPos * rndMult;\n\n\tvec4 mvPos = modelViewMatrix * vec4( iPos, 1.0 );\n\tmvPos.xyz += vPos;\n\tgl_Position = projectionMatrix * mvPos;\n\t\n\tvec3 worldPos = ( modelMatrix * vec4( iPos, 1.0 ) ).xyz;\n\tvCol = mix( col1, col2, smoothstep( -0.5, 0.5, dot( cameraPosition - worldPos, dir ) ) );\n\n}\n`;\n\nconst vis2BodyFrag = `\n\nuniform float uTime;\n\nvarying vec3 vCol;\n\nvoid main() {\n\n    gl_FragColor = vec4( vCol, 1.0 );\n\n}\n`;\n\n\n\nfunction vis2(faceGroup) {\n\n\t//vis\n\tconst vis = {};\n\n\tvis.spineElemR = 0.01;\n\tvis.spineElemH = 0.04;\n\tvis.bodyElemScale = 0.02;\n\tvis.numSpineInstances = 1024;\n\tvis.numBodyInstances = 512;\n\tvis.numSpineLoops = 323;\n\tvis.visAgents = [];\n\tvis.cols1 = [0x39998f, 0x6c43b3];\n\tvis.cols2 = [ 0xff4c4c, 0x45e6af];\n\tvis.bodyCols = [0xc84f43, 0xc84f43];\n\n\tvis.pos = new THREE.Vector3();\n\tvis.vec1 = new THREE.Vector3();\n\tvis.vec2 = new THREE.Vector3();\n\tvis.vec3 = new THREE.Vector3();\n\tvis.mat3 = new THREE.Matrix3();\n\tvis.mat4 = new THREE.Matrix4();\n\tvis.matRot4 = new THREE.Matrix4();\n\tvis.q1 = new THREE.Quaternion();\n\tvis.q2 = new THREE.Quaternion();\n\tvis.q3 = new THREE.Quaternion();\n\tvis.scale = new THREE.Vector3();\n\tvis.forward = new THREE.Vector3(0, 0, 1.0);\n\tvis.up = new THREE.Vector3(0, 1.0, 0);\n\n\tvis.tick = 0;\n\n\tvis.faceGroup = faceGroup;\t\n\n\tfor (let i = 0; i < agents.length; i++) {\n\n\t\tconst geo = new THREE.ConeGeometry(vis.spineElemR, vis.spineElemH, 5, 1);\n\t\tgeo.translate(0, vis.spineElemH * 0.5 + 0.05, 0);\n\n\t\tconst spikeUniforms = {\n\t\t\t\"col1\": { value: new THREE.Color(vis.cols1[i]) },\n\t\t\t\"col2_1\": { value: new THREE.Color(vis.cols2[i] ) },\n\t\t\t\"col2_2\": { value: new THREE.Color(vis.cols2[1 - i]) },\n\t\t\t\"groupPos\": { value: frontPos },\n\t\t\t\"groupDir\": { value: frontDir }\n\n\t\t\t\n\t\t};\n\t\tconst spikeMat = new THREE.ShaderMaterial({ uniforms: spikeUniforms, vertexShader: vis2SpikeVert, fragmentShader: vis2SpikeFrag });\n\t\t//mat.blending = THREE.AdditiveBlending;\n\t\t//const mat = new THREE.MeshBasicMaterial( { color: vis.cols[ i ] } );\n\t\t\n\t\tconst spikeMesh = new THREE.InstancedMesh(geo, spikeMat, vis.numSpineInstances);\n\t\tspikeMesh.instanceMatrix.setUsage(THREE.StreamDrawUsage);\n\t\tfaceGroup.add(spikeMesh);\n\n\t\tconst bodyUniforms = {\n\t\t\t\"col1\": { value: new THREE.Color(vis.bodyCols[i]) },\n\t\t\t\"col2\": { value: new THREE.Color(vis.bodyCols[1 - i]) },\n\t\t\t\"uTime\": { value: 0 }\n\t\t};\n\t\tconst bodyMat = new THREE.ShaderMaterial({ uniforms: bodyUniforms, vertexShader: vis2BodyVert, fragmentShader: vis2BodyFrag });\n\t\tbodyMat.blending = THREE.AdditiveBlending;\n\n\t\t//const bodyGeo = new THREE.IcosahedronGeometry( vis.bodyElemScale, 0 );\n\t\tconst bodyGeo = new THREE.CircleGeometry(vis.bodyElemScale, 8);\n\t\tconst bodyMesh = new THREE.InstancedMesh(bodyGeo, bodyMat, vis.numBodyInstances);\n\t\tfaceGroup.add(bodyMesh);\n\n\t\tconst agentData = { agent: agents[i], spikeMesh: spikeMesh, bodyMesh: bodyMesh, spikeUniforms: spikeUniforms, bodyUniforms: bodyUniforms, spikeData: [] };\n\n\t\tfor (let i = 0; i < vis.numSpineInstances; i++) {\n\n\t\t\tagentData.spikeData.push({ q: new THREE.Quaternion() });\n\n\t\t}\n\n\t\tconst bodyDirs = new Float32Array(vis.numBodyInstances * 3);\n\t\tconst bodyIPos = new Float32Array(vis.numBodyInstances * 3);\n\t\tconst bodyRndPos = new Float32Array(vis.numBodyInstances * 3);\n\t\tconst bodyT = new Float32Array(vis.numBodyInstances);\n\t\tfor (let i = 0; i < vis.numBodyInstances; i++) {\n\n\t\t\tlet rnd = new THREE.Vector3().randomDirection().multiplyScalar(0.05);\n\t\t\tbodyRndPos[i * 3] = rnd.x;\n\t\t\tbodyRndPos[i * 3 + 1] = rnd.y;\n\t\t\tbodyRndPos[i * 3 + 2] = rnd.z;\n\t\t\tbodyDirs[i * 3] = 0;\n\t\t\tbodyDirs[i * 3 + 1] = 0;\n\t\t\tbodyDirs[i * 3 + 2] = 0;\n\n\t\t\tbodyT[i] = i / (vis.numBodyInstances - 1);\n\n\t\t}\n\n\t\tconst bodyIposBuffer = new THREE.InstancedBufferAttribute(bodyIPos, 3);\n\t\tbodyIposBuffer.setUsage(THREE.StreamDrawUsage);\n\t\tbodyGeo.setAttribute('iPos', bodyIposBuffer);\n\t\tconst bodyDirsBuffer = new THREE.InstancedBufferAttribute(bodyDirs, 3);\n\t\tbodyDirsBuffer.setUsage(THREE.StreamDrawUsage);\n\t\tbodyGeo.setAttribute('dir', bodyDirsBuffer);\n\t\tbodyGeo.setAttribute('rndPos', new THREE.InstancedBufferAttribute(bodyRndPos, 3));\n\t\tbodyGeo.setAttribute('t', new THREE.InstancedBufferAttribute(bodyT, 1));\n\n\t\tvis.visAgents.push(agentData);\n\n\t}\n\n\tvis.update = function (deltaTime, time) {\n\n\t\tthis.tick += deltaTime;\n\n\t\tlet visAgent, visAgentWander;\n\t\tfor (let j = 0; j < vis.visAgents.length; j++) {\n\n\t\t\tvisAgent = this.visAgents[j];\n\t\t\tvisAgentWander = visAgent.agent.wander;\n\t\t\tvisAgent.bodyUniforms.uTime.value = this.tick;\n\t\t\tvisAgent.spikeUniforms.groupPos.value = leftPos;\n\t\t\tvisAgent.spikeUniforms.groupDir.value = leftDir;\n\n\t\t\tfor (let i = 0; i < this.numSpineInstances; i++) {\n\n\t\t\t\tlet t = i / this.numSpineInstances;\n\t\t\t\tlet segmentI = Math.floor(t * visAgentWander.numTrailSegments);\n\t\t\t\tlet segmentT = t * visAgentWander.numTrailSegments - Math.floor(t * visAgentWander.numTrailSegments);\n\t\t\t\tlet spikeData = visAgent.spikeData[i];\n\n\t\t\t\tif (segmentI < visAgentWander.numTrailSegments - 1) {\n\n\t\t\t\t\tthis.pos.copy(visAgentWander.trailSegments[segmentI]).lerp(visAgentWander.trailSegments[segmentI + 1], segmentT);\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis.pos.copy(visAgentWander.trailSegments[segmentI]);\n\n\t\t\t\t}\n\n\n\t\t\t\tif (segmentI == 0) {\n\n\t\t\t\t\tthis.vec2.copy(this.pos);\n\t\t\t\t\tthis.vec2.add(this.vec1.copy(visAgentWander.trailSegments[0]).sub(visAgentWander.trailSegments[1]).normalize());\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis.vec2.copy(this.pos);\n\t\t\t\t\tthis.vec2.add(this.vec1.copy(visAgentWander.trailSegments[segmentI - 1]).sub(visAgentWander.trailSegments[segmentI]).normalize());\n\n\t\t\t\t}\n\n\t\t\t\tthis.matRot4.lookAt(this.pos, this.vec2, this.up);\n\t\t\t\tthis.q1.setFromRotationMatrix(this.matRot4);\n\n\t\t\t\tthis.q2.setFromAxisAngle(this.forward, t * Math.PI * 2 * this.numSpineLoops + this.tick * 1.0);\n\t\t\t\tthis.q1.multiply(this.q2);\n\n\t\t\t\tspikeData.q.slerp(this.q1, deltaTime * 2.0);\n\n\t\t\t\tlet scXY = THREE.MathUtils.smoothstep(t, 0, 0.1) * (1.0 - THREE.MathUtils.smoothstep(t, 0.9, 1.0)) * 1.0;\n\t\t\t\tlet sc = Math.max(scXY + Math.sin(t * Math.PI * 2 * 30.0 + this.tick * -3.0) * (scXY * 0.9), 0.3);\n\t\t\t\tsc = scXY;\n\t\t\t\tthis.scale.setScalar(sc);\n\n\t\t\t\tlet rndMult = Math.max(scXY + Math.sin(t * Math.PI * 4) * 0.4 + Math.sin(t * Math.PI * 5 - this.tick * 4.0) * 0.4, 0.1);\n\n\t\t\t\tthis.mat4.compose(this.pos, spikeData.q, this.scale);\n\n\t\t\t\tvisAgent.spikeMesh.setMatrixAt(i, this.mat4);\n\n\t\t\t}\n\n\n\t\t\tlet bodyDirs = visAgent.bodyMesh.geometry.getAttribute(\"dir\");\n\t\t\tlet bodyIPos = visAgent.bodyMesh.geometry.getAttribute(\"iPos\");\n\n\t\t\tfor (let i = 0; i < this.numBodyInstances; i++) {\n\n\t\t\t\tlet t = i / this.numBodyInstances;\n\t\t\t\tlet segmentI = Math.floor(t * visAgentWander.numTrailSegments);\n\t\t\t\tlet segmentT = t * visAgentWander.numTrailSegments - Math.floor(t * visAgentWander.numTrailSegments);\n\n\t\t\t\tif (segmentI < visAgentWander.numTrailSegments - 1) {\n\n\t\t\t\t\tthis.pos.copy(visAgentWander.trailSegments[segmentI]).lerp(visAgentWander.trailSegments[segmentI + 1], segmentT);\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis.pos.copy(visAgentWander.trailSegments[segmentI]);\n\n\t\t\t\t}\n\n\n\t\t\t\tif (segmentI == 0) {\n\n\t\t\t\t\tthis.vec2.copy(this.pos);\n\t\t\t\t\tthis.vec2.add(this.vec1.copy(visAgentWander.trailSegments[0]).sub(visAgentWander.trailSegments[1]).normalize());\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis.vec2.copy(this.pos);\n\t\t\t\t\tthis.vec2.add(this.vec1.copy(visAgentWander.trailSegments[segmentI - 1]).sub(visAgentWander.trailSegments[segmentI]).normalize());\n\n\t\t\t\t}\n\n\t\t\t\tbodyDirs.setXYZ(i, this.vec2.x, this.vec2.y, this.vec2.z);\n\t\t\t\tbodyIPos.setXYZ(i, this.pos.x, this.pos.y, this.pos.z);\n\n\t\t\t}\n\n\t\t\tvisAgent.spikeMesh.instanceMatrix.needsUpdate = true;\n\t\t\tbodyDirs.needsUpdate = true;\n\t\t\tbodyIPos.needsUpdate = true;\n\n\t\t}\n\n\t}\n\n\treturn vis;\n\n}\n\n\n\n//\n//vis3 - top/bottom\n//\n\nconst vis3SpikeVert = `\n\nuniform vec3 col1;\nuniform vec3 col2_1;\nuniform vec3 col2_2;\nvarying vec3 vCol;\nuniform vec3 groupPos;\nuniform vec3 groupDir;\n\nvoid main() {\n\n\tvec4 vPos = vec4( position, 1.0 );\n    vec4 iPos = instanceMatrix * vPos;\n    vec4 worldPos = modelMatrix * iPos;\n    vec4 viewPos = viewMatrix * worldPos;\n\n\tvec3 vCol1 = col1;\n\t\n\tvCol = vCol1;\t\n\t\n    gl_Position = projectionMatrix * viewPos;\n\n}\n`;\n\nconst vis3SpikeFrag = `\n\nuniform float uTime;\nvarying vec3 vCol;\n\nvoid main() {\n\n    gl_FragColor = vec4( vCol, 1.0 );\n\n}\n`;\n\nconst vis3BodyVert = `\n\n#define PI 3.141592653589793\nattribute vec3 iPos;\nattribute vec3 rndPos;\nattribute vec3 dir;\nattribute float t;\nuniform vec3 col1;\nuniform vec3 col2;\nuniform float uTime;\nvarying vec3 vCol;\n\nvoid main() {\n\t\n\tfloat scXY = smoothstep( 0.0, 0.1, t ) * ( 1.0 - smoothstep( 0.9, 1.0, t ) ) * 0.2;\n\tfloat sc = max( scXY + sin( t * PI * 2.0 * 30.0 + uTime * -3.0 ) * scXY, 0.3 );\n\tfloat rndMult = max ( scXY + sin( t * PI * 4.0 ) * 0.4 + sin( t * PI * 5.0 - uTime * 4.0 ) * 0.4, 0.1 );\n\n\tvec3 pos = position;\n\tpos *= sc;\n\n\tvec3 vPos = pos + rndPos * rndMult;\n\n\tvec4 mvPos = modelViewMatrix * vec4( iPos, 1.0 );\n\tmvPos.xyz += vPos;\n\tgl_Position = projectionMatrix * mvPos;\n\t\n\tvec3 worldPos = ( modelMatrix * vec4( iPos, 1.0 ) ).xyz;\n\tvCol = mix( col1, col2, smoothstep( -0.5, 0.5, dot( cameraPosition - worldPos, dir ) ) );\n\n}\n`;\n\nconst vis3BodyFrag = `\n\nuniform float uTime;\n\nvarying vec3 vCol;\n\nvoid main() {\n\n    gl_FragColor = vec4( vCol, 1.0 );\n\n}\n`;\n\n\n\nfunction vis3(faceGroup) {\n\n\t//vis\n\tconst vis = {};\n\n\tvis.spineElemR = 0.01;\n\tvis.spineElemH = 0.04;\n\tvis.bodyElemScale = 0.02;\n\tvis.numSpineInstances = 1024;\n\tvis.numBodyInstances = 512;\n\tvis.numSpineLoops = 323;\n\tvis.visAgents = [];\n\tvis.cols1 = [0x000000, 0x222222];\n\tvis.cols2 = [ 0x222222, 0x000000];\n\tvis.bodyCols = [0xFFFFFF, 0xFFFFFF];\n\n\tvis.pos = new THREE.Vector3();\n\tvis.vec1 = new THREE.Vector3();\n\tvis.vec2 = new THREE.Vector3();\n\tvis.vec3 = new THREE.Vector3();\n\tvis.mat3 = new THREE.Matrix3();\n\tvis.mat4 = new THREE.Matrix4();\n\tvis.matRot4 = new THREE.Matrix4();\n\tvis.q1 = new THREE.Quaternion();\n\tvis.q2 = new THREE.Quaternion();\n\tvis.q3 = new THREE.Quaternion();\n\tvis.scale = new THREE.Vector3();\n\tvis.forward = new THREE.Vector3(0, 0, 1.0);\n\tvis.up = new THREE.Vector3(0, 1.0, 0);\n\n\tvis.tick = 0;\n\n\tvis.faceGroup = faceGroup;\t\n\n\tfor (let i = 0; i < agents.length; i++) {\n\n\t\tconst geo = new THREE.ConeGeometry(vis.spineElemR, vis.spineElemH, 5, 1);\n\t\tgeo.translate(0, vis.spineElemH * 0.5 + 0.05, 0);\n\n\t\tconst spikeUniforms = {\n\t\t\t\"col1\": { value: new THREE.Color(vis.cols1[i]) },\n\t\t\t\"col2_1\": { value: new THREE.Color(vis.cols2[i] ) },\n\t\t\t\"col2_2\": { value: new THREE.Color(vis.cols2[1 - i]) },\n\t\t\t\"groupPos\": { value: frontPos },\n\t\t\t\"groupDir\": { value: frontDir }\n\n\t\t\t\n\t\t};\n\t\tconst spikeMat = new THREE.ShaderMaterial({ uniforms: spikeUniforms, vertexShader: vis3SpikeVert, fragmentShader: vis3SpikeFrag });\n\t\t//mat.blending = THREE.AdditiveBlending;\n\t\t//const mat = new THREE.MeshBasicMaterial( { color: vis.cols[ i ] } );\n\t\t\n\t\tconst spikeMesh = new THREE.InstancedMesh(geo, spikeMat, vis.numSpineInstances);\n\t\tspikeMesh.instanceMatrix.setUsage(THREE.StreamDrawUsage);\n\t\tfaceGroup.add(spikeMesh);\n\n\t\tconst bodyUniforms = {\n\t\t\t\"col1\": { value: new THREE.Color(vis.bodyCols[i]) },\n\t\t\t\"col2\": { value: new THREE.Color(vis.bodyCols[1 - i]) },\n\t\t\t\"uTime\": { value: 0 }\n\t\t};\n\t\tconst bodyMat = new THREE.ShaderMaterial({ uniforms: bodyUniforms, vertexShader: vis3BodyVert, fragmentShader: vis3BodyFrag });\n\t\tbodyMat.blending = THREE.AdditiveBlending;\n\n\t\t//const bodyGeo = new THREE.IcosahedronGeometry( vis.bodyElemScale, 0 );\n\t\tconst bodyGeo = new THREE.CircleGeometry(vis.bodyElemScale, 8);\n\t\tconst bodyMesh = new THREE.InstancedMesh(bodyGeo, bodyMat, vis.numBodyInstances);\n\t\tfaceGroup.add(bodyMesh);\n\n\t\tconst agentData = { agent: agents[i], spikeMesh: spikeMesh, bodyMesh: bodyMesh, spikeUniforms: spikeUniforms, bodyUniforms: bodyUniforms, spikeData: [] };\n\n\t\tfor (let i = 0; i < vis.numSpineInstances; i++) {\n\n\t\t\tagentData.spikeData.push({ q: new THREE.Quaternion() });\n\n\t\t}\n\n\t\tconst bodyDirs = new Float32Array(vis.numBodyInstances * 3);\n\t\tconst bodyIPos = new Float32Array(vis.numBodyInstances * 3);\n\t\tconst bodyRndPos = new Float32Array(vis.numBodyInstances * 3);\n\t\tconst bodyT = new Float32Array(vis.numBodyInstances);\n\t\tfor (let i = 0; i < vis.numBodyInstances; i++) {\n\n\t\t\tlet rnd = new THREE.Vector3().randomDirection().multiplyScalar(0.05);\n\t\t\tbodyRndPos[i * 3] = rnd.x;\n\t\t\tbodyRndPos[i * 3 + 1] = rnd.y;\n\t\t\tbodyRndPos[i * 3 + 2] = rnd.z;\n\t\t\tbodyDirs[i * 3] = 0;\n\t\t\tbodyDirs[i * 3 + 1] = 0;\n\t\t\tbodyDirs[i * 3 + 2] = 0;\n\n\t\t\tbodyT[i] = i / (vis.numBodyInstances - 1);\n\n\t\t}\n\n\t\tconst bodyIposBuffer = new THREE.InstancedBufferAttribute(bodyIPos, 3);\n\t\tbodyIposBuffer.setUsage(THREE.StreamDrawUsage);\n\t\tbodyGeo.setAttribute('iPos', bodyIposBuffer);\n\t\tconst bodyDirsBuffer = new THREE.InstancedBufferAttribute(bodyDirs, 3);\n\t\tbodyDirsBuffer.setUsage(THREE.StreamDrawUsage);\n\t\tbodyGeo.setAttribute('dir', bodyDirsBuffer);\n\t\tbodyGeo.setAttribute('rndPos', new THREE.InstancedBufferAttribute(bodyRndPos, 3));\n\t\tbodyGeo.setAttribute('t', new THREE.InstancedBufferAttribute(bodyT, 1));\n\n\t\tvis.visAgents.push(agentData);\n\n\t}\n\n\tvis.update = function (deltaTime, time) {\n\n\t\tthis.tick += deltaTime;\n\n\t\tlet visAgent, visAgentWander;\n\t\tfor (let j = 0; j < vis.visAgents.length; j++) {\n\n\t\t\tvisAgent = this.visAgents[j];\n\t\t\tvisAgentWander = visAgent.agent.wander;\n\t\t\tvisAgent.bodyUniforms.uTime.value = this.tick;\n\t\t\tvisAgent.spikeUniforms.groupPos.value = leftPos;\n\t\t\tvisAgent.spikeUniforms.groupDir.value = leftDir;\n\n\t\t\tfor (let i = 0; i < this.numSpineInstances; i++) {\n\n\t\t\t\tlet t = i / this.numSpineInstances;\n\t\t\t\tlet segmentI = Math.floor(t * visAgentWander.numTrailSegments);\n\t\t\t\tlet segmentT = t * visAgentWander.numTrailSegments - Math.floor(t * visAgentWander.numTrailSegments);\n\t\t\t\tlet spikeData = visAgent.spikeData[i];\n\n\t\t\t\tif (segmentI < visAgentWander.numTrailSegments - 1) {\n\n\t\t\t\t\tthis.pos.copy(visAgentWander.trailSegments[segmentI]).lerp(visAgentWander.trailSegments[segmentI + 1], segmentT);\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis.pos.copy(visAgentWander.trailSegments[segmentI]);\n\n\t\t\t\t}\n\n\n\t\t\t\tif (segmentI == 0) {\n\n\t\t\t\t\tthis.vec2.copy(this.pos);\n\t\t\t\t\tthis.vec2.add(this.vec1.copy(visAgentWander.trailSegments[0]).sub(visAgentWander.trailSegments[1]).normalize());\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis.vec2.copy(this.pos);\n\t\t\t\t\tthis.vec2.add(this.vec1.copy(visAgentWander.trailSegments[segmentI - 1]).sub(visAgentWander.trailSegments[segmentI]).normalize());\n\n\t\t\t\t}\n\n\t\t\t\tthis.matRot4.lookAt(this.pos, this.vec2, this.up);\n\t\t\t\tthis.q1.setFromRotationMatrix(this.matRot4);\n\n\t\t\t\tthis.q2.setFromAxisAngle(this.forward, t * Math.PI * 2 * this.numSpineLoops + this.tick * 1.0);\n\t\t\t\tthis.q1.multiply(this.q2);\n\n\t\t\t\tspikeData.q.slerp(this.q1, deltaTime * 2.0);\n\n\t\t\t\tlet scXY = THREE.MathUtils.smoothstep(t, 0, 0.1) * (1.0 - THREE.MathUtils.smoothstep(t, 0.9, 1.0)) * 1.0;\n\t\t\t\tlet sc = Math.max(scXY + Math.sin(t * Math.PI * 2 * 30.0 + this.tick * -3.0) * (scXY * 0.9), 0.3);\n\t\t\t\tsc = scXY;\n\t\t\t\tthis.scale.setScalar(sc);\n\n\t\t\t\tlet rndMult = Math.max(scXY + Math.sin(t * Math.PI * 4) * 0.4 + Math.sin(t * Math.PI * 5 - this.tick * 4.0) * 0.4, 0.1);\n\n\t\t\t\tthis.mat4.compose(this.pos, spikeData.q, this.scale);\n\n\t\t\t\tvisAgent.spikeMesh.setMatrixAt(i, this.mat4);\n\n\t\t\t}\n\n\n\t\t\tlet bodyDirs = visAgent.bodyMesh.geometry.getAttribute(\"dir\");\n\t\t\tlet bodyIPos = visAgent.bodyMesh.geometry.getAttribute(\"iPos\");\n\n\t\t\tfor (let i = 0; i < this.numBodyInstances; i++) {\n\n\t\t\t\tlet t = i / this.numBodyInstances;\n\t\t\t\tlet segmentI = Math.floor(t * visAgentWander.numTrailSegments);\n\t\t\t\tlet segmentT = t * visAgentWander.numTrailSegments - Math.floor(t * visAgentWander.numTrailSegments);\n\n\t\t\t\tif (segmentI < visAgentWander.numTrailSegments - 1) {\n\n\t\t\t\t\tthis.pos.copy(visAgentWander.trailSegments[segmentI]).lerp(visAgentWander.trailSegments[segmentI + 1], segmentT);\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis.pos.copy(visAgentWander.trailSegments[segmentI]);\n\n\t\t\t\t}\n\n\n\t\t\t\tif (segmentI == 0) {\n\n\t\t\t\t\tthis.vec2.copy(this.pos);\n\t\t\t\t\tthis.vec2.add(this.vec1.copy(visAgentWander.trailSegments[0]).sub(visAgentWander.trailSegments[1]).normalize());\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis.vec2.copy(this.pos);\n\t\t\t\t\tthis.vec2.add(this.vec1.copy(visAgentWander.trailSegments[segmentI - 1]).sub(visAgentWander.trailSegments[segmentI]).normalize());\n\n\t\t\t\t}\n\n\t\t\t\tbodyDirs.setXYZ(i, this.vec2.x, this.vec2.y, this.vec2.z);\n\t\t\t\tbodyIPos.setXYZ(i, this.pos.x, this.pos.y, this.pos.z);\n\n\t\t\t}\n\n\t\t\tvisAgent.spikeMesh.instanceMatrix.needsUpdate = true;\n\t\t\tbodyDirs.needsUpdate = true;\n\t\t\tbodyIPos.needsUpdate = true;\n\n\t\t}\n\n\t}\n\n\treturn vis;\n\n}\n\n\n"
			}],
		"bb47580c-0ba3-4701-a8cc-a859ba88f405": [
			{
				"name": "frontBG",
				"source": "\nconst worldPos = new THREE.Vector3();\nconst worldDir = new THREE.Vector3();\n\nfunction init() {\n\t\t\n\tthis.getWorldPosition( worldPos );\n\tthis.getWorldDirection( worldDir );\n\t\n\tthis.material.uniforms = {\n\n\t\tcolFront1: { value: new THREE.Color( 0x281023 ) },\n\t\tcolFront2: { value: new THREE.Color( 0x522232 ) },\t\n\t\tcolFront3: { value: new THREE.Color( 0x2f2b42 ) },\t\t\n\t\tcolBack1: { value: new THREE.Color( 0x0c1e25 ) },\n\t\tcolBack2: { value: new THREE.Color( 0x0e2d3b ) },\n\t\tcolBack3: { value: new THREE.Color( 0x0d0f18 ) },\n\t\tgroupPos: { value: worldPos },\n\t\tgroupDir: { value: worldDir }\n\t\t\n\t}\n\n\t/*\n\tthis.material.uniforms = {\n\n\t\tcol1: { value: new THREE.Color( 0xFF0000 ) },\n\t\tcol2: { value: new THREE.Color( 0x0000FF ) },\n\t\tcol3: { value: new THREE.Color( 0x00FF00 ) }\t\t\n\t\t\n\t}\t\n\t*/\n\t\n}\n\nfunction update() {\n\n\tthis.getWorldPosition( worldPos );\n\tthis.getWorldDirection( worldDir );\n\tthis.material.uniforms.groupPos.value = worldPos;\n\tthis.material.uniforms.groupDir.value = worldDir;\n\t\n}"
			}],
		"6499bc57-679f-4a63-bf90-d2b45c5834f9": [
			{
				"name": "leftBG",
				"source": "\nconst worldPos = new THREE.Vector3();\nconst worldDir = new THREE.Vector3();\n\nfunction init() {\n\t\t\n\tthis.getWorldPosition( worldPos );\n\tthis.getWorldDirection( worldDir );\n\t\n\tthis.material.uniforms = {\n\n\t\tcolFront1: { value: new THREE.Color( 0x19060f ) },\n\t\tcolFront2: { value: new THREE.Color( 0x4d0c3d ) },\t\n\t\tcolFront3: { value: new THREE.Color( 0x19060f ) },\t\t\n\t\tcolBack1: { value: new THREE.Color( 0x072d2d ) },\n\t\tcolBack2: { value: new THREE.Color( 0x000000 ) },\n\t\tcolBack3: { value: new THREE.Color( 0x072d2d ) },\n\t\tgroupPos: { value: worldPos },\n\t\tgroupDir: { value: worldDir }\n\t\t\n\t}\n\n\t/*\n\tthis.material.uniforms = {\n\n\t\tcol1: { value: new THREE.Color( 0xFF0000 ) },\n\t\tcol2: { value: new THREE.Color( 0x0000FF ) },\n\t\tcol3: { value: new THREE.Color( 0x00FF00 ) }\t\t\n\t\t\n\t}\t\n\t*/\n\t\n}\n\nfunction update() {\n\n\tthis.getWorldPosition( worldPos );\n\tthis.getWorldDirection( worldDir );\n\tthis.material.uniforms.groupPos.value = worldPos;\n\tthis.material.uniforms.groupDir.value = worldDir;\n\t\n}"
			}]
	}
}