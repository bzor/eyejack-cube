{
	"metadata": {
		"type": "App"
	},
	"project": {
		"shadows": false,
		"shadowType": 0,
		"useLegacyLights": false,
		"toneMapping": 0,
		"toneMappingExposure": 1,
		"postprocessing": [
			{
				"type": "bloom",
				"bloomThreshold": 0.1,
				"bloomStrength": 1.8,
				"bloomRadius": 0.05,
				"exposure": 1
			}],
		"projectType": "EJXCube",
		"cubeType": "Plain",
		"faceFront": "5be9dfb5-726e-4931-8e5c-49e3b6ccb589",
		"faceRight": "4dd5b36d-97e1-445b-aebb-acc109a4329e",
		"faceBack": "5be9dfb5-726e-4931-8e5c-49e3b6ccb589",
		"faceLeft": "4dd5b36d-97e1-445b-aebb-acc109a4329e",
		"faceTop": "6ee5ad3d-e96e-49a3-984b-02a57a8501bd",
		"faceBottom": "6ee5ad3d-e96e-49a3-984b-02a57a8501bd"
	},
	"camera": {
		"metadata": {
			"version": 4.5,
			"type": "Object",
			"generator": "Object3D.toJSON"
		},
		"object": {
			"uuid": "e5d02aa7-ad7c-4f03-88bc-87803202f49a",
			"type": "PerspectiveCamera",
			"name": "Camera",
			"layers": 1,
			"matrix": [0.32959569652017734,1.3877787807814449e-17,0.9441221726214135,0,0.1398983062084619,0.9889606800408437,-0.0488388907854416,0,-0.9336997058773129,0.14817818102928945,0.3259571841691304,0,-2.0046749073046204,0.3181419887461012,0.6998376285719725,1],
			"up": [0,1,0],
			"fov": 50,
			"zoom": 1,
			"near": 0.01,
			"far": 50,
			"focus": 10,
			"aspect": 1.0738095238095238,
			"filmGauge": 35,
			"filmOffset": 0
		}
	},
	"scene": {
		"metadata": {
			"version": 4.5,
			"type": "Object",
			"generator": "Object3D.toJSON"
		},
		"geometries": [
			{
				"uuid": "ae5715e0-0a3b-40ec-adb8-637b20997a07",
				"type": "BoxGeometry",
				"width": 2,
				"height": 2,
				"depth": 2,
				"widthSegments": 1,
				"heightSegments": 1,
				"depthSegments": 1
			}],
		"materials": [
			{
				"uuid": "36524130-6400-454f-8577-5f9d9be1b61c",
				"type": "MeshBasicMaterial",
				"color": 1184274,
				"reflectivity": 1,
				"refractionRatio": 0.98,
				"blending": 2,
				"side": 1,
				"depthFunc": 3,
				"depthTest": true,
				"depthWrite": true,
				"colorWrite": true,
				"stencilWrite": false,
				"stencilWriteMask": 255,
				"stencilFunc": 519,
				"stencilRef": 0,
				"stencilFuncMask": 255,
				"stencilFail": 7680,
				"stencilZFail": 7680,
				"stencilZPass": 7680
			}],
		"object": {
			"uuid": "31517222-A9A7-4EAF-B5F6-60751C0BABA3",
			"type": "Scene",
			"name": "Scene",
			"layers": 1,
			"matrix": [1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],
			"up": [0,1,0],
			"children": [
				{
					"uuid": "6ee5ad3d-e96e-49a3-984b-02a57a8501bd",
					"type": "Group",
					"name": "faceTop",
					"layers": 1,
					"matrix": [1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],
					"up": [0,1,0],
					"children": [
						{
							"uuid": "b4a2be5a-480a-4dfc-bfb5-8966ae51d74d",
							"type": "Mesh",
							"name": "bg",
							"layers": 1,
							"matrix": [1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],
							"up": [0,1,0],
							"geometry": "ae5715e0-0a3b-40ec-adb8-637b20997a07",
							"material": "36524130-6400-454f-8577-5f9d9be1b61c"
						}]
				},
				{
					"uuid": "5be9dfb5-726e-4931-8e5c-49e3b6ccb589",
					"type": "Group",
					"name": "faceFront",
					"layers": 1,
					"matrix": [1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],
					"up": [0,1,0]
				},
				{
					"uuid": "4dd5b36d-97e1-445b-aebb-acc109a4329e",
					"type": "Group",
					"name": "faceLeft",
					"layers": 1,
					"matrix": [1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],
					"up": [0,1,0]
				}]
		}
	},
	"scripts": {
		"31517222-A9A7-4EAF-B5F6-60751C0BABA3": [
			{
				"name": "main",
				"source": "//wander settings\nconst wanderSettings = {};\nwanderSettings.boundingSphereRadius = 0.5;\nwanderSettings.wanderSphereDistance = 0.1;\nwanderSettings.wanderSphereRadius = 8;\nwanderSettings.wanderAngleMaxChange = 12;\nwanderSettings.wanderBoundsAngleMaxChange = 12;\nwanderSettings.maxVelocity = 0.008;\nwanderSettings.maxSteeringForce = 8;\nwanderSettings.trailAvoidDist = 0.03;\nwanderSettings.trailDropDelay = 0.015;\nwanderSettings.numTrailSegments = 256;\nwanderSettings.dustAvoidDist = 0.04;\n\nconst agents = [];\nconst agentVizs = [];\n\nlet dust;\nconst numDust = 4096;\n\nlet faceFront;\nlet faceFrontEnv;\nconst frontPos = new THREE.Vector3();\nconst frontDir = new THREE.Vector3();\nlet faceLeft;\nlet faceLeftEnv;\nconst leftPos = new THREE.Vector3();\nconst leftDir = new THREE.Vector3();\nlet faceTop;\n\nlet faceFrontBG;\nlet faceLeftBG;\n\nconst bgFrontUniforms = {\n\n\tcolFront1: { value: new THREE.Color(0x281023) },\n\tcolFront2: { value: new THREE.Color(0x522232) },\n\tcolFront3: { value: new THREE.Color(0x2f2b42) },\n\tcolBack1: { value: new THREE.Color(0x0c1e25) },\n\tcolBack2: { value: new THREE.Color(0x0e2d3b) },\n\tcolBack3: { value: new THREE.Color(0x0d0f18) },\n\tgroupPos: { value: new THREE.Vector3() },\n\tgroupDir: { value: new THREE.Vector3() }\n\n}\n\nconst bgLeftUniforms = {\n\n\tcolFront1: { value: new THREE.Color(0x19060f) },\n\tcolFront2: { value: new THREE.Color(0x4d0c3d) },\n\tcolFront3: { value: new THREE.Color(0x19060f) },\n\tcolBack1: { value: new THREE.Color(0x02c050a) },\n\tcolBack2: { value: new THREE.Color(0x000000) },\n\tcolBack3: { value: new THREE.Color(0x2c050a) },\n\tgroupPos: { value: new THREE.Vector3() },\n\tgroupDir: { value: new THREE.Vector3() }\n\n}\n\n\nfunction init() {\n\n\tconsole.log(\"init main\");\n\tlet agentData1 = { wander: createWander(this), id: 0 };\n\tagents.push(agentData1);\n\tlet agentData2 = { wander: createWander(this), id: 1 };\n\tagents.push(agentData2);\n\n\tfaceFront = this.getObjectByName(\"faceFront\");\n\tfaceFrontBG = createBG(faceFront, bgFrontUniforms, 0);\n\tfaceFrontEnv = faceFrontBG.mesh;\n\tfaceFrontEnv.getWorldPosition(frontPos);\n\tfaceFrontEnv.getWorldDirection(frontDir);\n\tfaceLeft = this.getObjectByName(\"faceLeft\");\n\tfaceLeftBG = createBG(faceLeft, bgLeftUniforms, Math.PI * 0.5);\n\tfaceLeftEnv = faceLeftBG.mesh;\n\tfaceLeftEnv.getWorldPosition(leftPos);\n\tfaceLeftEnv.getWorldDirection(leftDir);\n\tfaceTop = this.getObjectByName(\"faceTop\");\n\n\tagentVizs.push(vis1(faceFront));\n\tagentVizs.push(vis2(faceLeft));\n\tagentVizs.push(vis3(faceTop));\n\n\tdust = createDust();\n\tfaceFront.add(dust.meshFront);\n\tfaceLeft.add(dust.meshLeft);\n\n}\n\nfunction update(event) {\n\n\tconst deltaTime = event.delta * 0.001;\n\tconst time = event.time;\n\n\tfaceFrontEnv.getWorldPosition(frontPos);\n\tfaceFrontEnv.getWorldDirection(frontDir);\n\tfaceLeftEnv.getWorldPosition(leftPos);\n\tfaceLeftEnv.getWorldDirection(leftDir);\n\n\tfor (let i = 0; i < agents.length; i++) {\n\n\t\tupdateAgent(agents[i], deltaTime);\n\n\t}\n\n\tfor (let i = 0; i < agentVizs.length; i++) {\n\n\t\tagentVizs[i].update(deltaTime, time);\n\n\t}\n\n\tupdateDust(deltaTime);\n\n\tupdateBGs(faceFrontBG, frontPos, frontDir);\n\n}\n\n//\n//agents\n//\n\nfunction updateAgent(agentData, deltaTime) {\n\n\tconst wander = agentData.wander;\n\n\twander.agentLookat.position.copy(wander.agentPoint);\n\n\twander.vec1.copy(wander.agentPoint);\n\n\tlet distanceFromCenter = wander.vec1.sub(wander.centerPoint).length();\n\tif (distanceFromCenter > wanderSettings.boundingSphereRadius) {\n\n\t\twander.agentLookat.lookAt(wander.centerPoint);\n\t\twander.wanderAngle.rotateTowards(wander.agentLookat.quaternion, wanderSettings.wanderBoundsAngleMaxChange * deltaTime);\n\n\t}\n\n\t//attract heads\n\twander.trailAvoidForce.setScalar(0);\n\tfor (let i = 0; i < agents.length; i++) {\n\n\t\tlet agent = agents[i];\n\t\tif (agent.wander == wander) {\n\n\t\t\tcontinue;\n\n\t\t}\n\n\t\tlet attactMult = 3;\n\t\twander.vec1.copy(agent.wander.agentPoint).sub(wander.agentPoint).normalize().multiplyScalar(attactMult);\n\t\twander.trailAvoidForce.add(wander.vec1);\n\n\t}\n\n\t//avoid trails\n\tfor (let i = 0; i < agents.length; i++) {\n\n\t\tlet agent = agents[i];\n\n\t\tlet jStart = (i == agents[i].id) ? Math.floor(wanderSettings.numTrailSegments) * 0.5 : 0;\n\n\t\tfor (let j = 0; j < wanderSettings.numTrailSegments; j++) {\n\n\t\t\twander.vec1.copy(agent.wander.trailSegments[j]);\n\t\t\tlet dist = wander.vec1.distanceToSquared(wander.agentPoint);\n\t\t\tif (dist < wanderSettings.trailAvoidDist) {\n\n\t\t\t\tlet forceMult = (wanderSettings.trailAvoidDist - dist) * 50.0;\n\t\t\t\twander.vec1.copy(wander.agentPoint).sub(agent.wander.trailSegments[j]).normalize().multiplyScalar(forceMult);\n\t\t\t\twander.trailAvoidForce.add(wander.vec1);\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\twander.wanderSphereCenter.copy(wander.currentVelocity).normalize().multiplyScalar(wanderSettings.wanderSphereDistance);\n\twander.q1.random();\n\twander.wanderAngle.rotateTowards(wander.q1, wanderSettings.wanderAngleMaxChange * deltaTime);\n\twander.wanderForce.setScalar(0);\n\twander.wanderDir.copy(wander.forward).applyQuaternion(wander.wanderAngle).multiplyScalar(wanderSettings.wanderSphereRadius);\n\twander.wanderForce.copy(wander.wanderSphereCenter).add(wander.wanderDir);\n\twander.wanderForce.clampLength(0, wanderSettings.maxSteeringForce);\n\n\twander.wanderForce.add(wander.trailAvoidForce);\n\twander.vec1.copy(wander.wanderForce).multiplyScalar(deltaTime);\n\twander.currentVelocity.add(wander.vec1);\n\twander.currentVelocity.clampLength(0, wanderSettings.maxVelocity);\n\n\twander.agentPoint.add(wander.currentVelocity);\n\n\twander.trailDropTick += deltaTime;\n\tif (wander.trailDropTick > wanderSettings.trailDropDelay) {\n\n\t\twander.trailDropTick = 0;\n\n\t\tfor (let i = wanderSettings.numTrailSegments - 1; i > 0; i--) {\n\n\t\t\twander.trailSegments[i].copy(wander.trailSegments[i - 1]);\n\n\t\t}\n\t\twander.trailSegments[0].copy(wander.agentPoint);\n\n\t}\n\n}\n\nfunction createWander(scene) {\n\n\tconst wander = {};\n\n\twander.vec1 = new THREE.Vector3();\n\twander.vec2 = new THREE.Vector3();\n\twander.vec3 = new THREE.Vector3();\n\twander.vec4 = new THREE.Vector3();\n\twander.q1 = new THREE.Quaternion();\n\twander.forward = new THREE.Vector3(0, 0, 1.0);\n\n\twander.agentPoint = new THREE.Vector3(0.05, 0.05, 0.05);\n\twander.agentLookat = new THREE.Object3D();\n\n\twander.currentPosition = new THREE.Vector3();\n\n\twander.centerPoint = new THREE.Vector3();\n\n\twander.currentVelocity = new THREE.Vector3().randomDirection().multiplyScalar(wanderSettings.maxVelocity);\n\twander.maxVelocitySq = wanderSettings.maxVelocity * wanderSettings.maxVelocity;\n\n\twander.boundingForce = new THREE.Vector3();\n\n\twander.wanderAngle = new THREE.Quaternion().random();\n\twander.wanderSphereCenter = new THREE.Vector3();\n\twander.wanderForce = new THREE.Vector3();\n\twander.wanderDir = new THREE.Vector3();\n\n\twander.trailAvoidDist = wanderSettings.trailAvoidDist * wanderSettings.trailAvoidDist;\n\twander.trailAvoidForce = new THREE.Vector3();\n\twander.trailDropTick = 0;\n\twander.numTrailSegments = wanderSettings.numTrailSegments;\n\twander.trailSegments = [];\n\tfor (let i = 0; i < wanderSettings.numTrailSegments; i++) {\n\n\t\twander.trailSegments.push(new THREE.Vector3());\n\n\t}\n\n\treturn wander;\n\n}\n\n//\n//dust\n//\n\nconst dustVert = `\n\nattribute vec3 iPos;\nattribute float activate;\nuniform vec3 col;\nvarying vec3 vCol;\n\nvoid main() {\n\t\n\tvCol = col + vec3( 0.4, 0.7, 1.0 ) * activate;\n\tvec4 mvPos = modelViewMatrix * vec4( iPos, 1.0 );\n\tmvPos.xyz += position;\n\tgl_Position = projectionMatrix * mvPos;\n\n}\n`;\n\nconst dustFrag = `\n\nvarying vec3 vCol;\n\nvoid main() {\n\n\tvec4 col = vec4( vCol, 1.0 );\n    gl_FragColor = col;\n\n}\n`;\n\nfunction createDust() {\n\n\tconst dust = {};\n\tconst points = new Float32Array(numDust * 3);\n\tconst activates = new Float32Array(numDust);\n\tconst velocities = [];\n\tlet v = new THREE.Vector3();\n\tfor (let i = 0; i < numDust; i++) {\n\n\t\tlet x = THREE.MathUtils.randFloatSpread(1.0);\n\t\tlet y = THREE.MathUtils.randFloatSpread(1.0);\n\t\tlet z = THREE.MathUtils.randFloatSpread(1.0);\n\n\t\tpoints[i * 3] = x;\n\t\tpoints[i * 3 + 1] = y;\n\t\tpoints[i * 3 + 2] = z;\n\n\t\tv.randomDirection().multiplyScalar(0.02);\n\t\tvelocities.push(v.clone());\n\n\t}\n\n\tconst mat = new THREE.ShaderMaterial({ uniforms: { col: { value: new THREE.Color(0x222244) }, pixelRatio: { value: window.devicePixelRatio } }, vertexShader: dustVert, fragmentShader: dustFrag });\n\tmat.blending = THREE.AdditiveBlending;\n\n\tconst dustGeo = new THREE.CircleGeometry(0.0025, 5);\n\n\tconst pointBuffer = new THREE.InstancedBufferAttribute(points, 3);\n\tpointBuffer.setUsage(THREE.StreamDrawUsage);\n\tdustGeo.setAttribute('iPos', pointBuffer);\n\n\tconst activateBuffer = new THREE.InstancedBufferAttribute(activates, 1);\n\tactivateBuffer.setUsage(THREE.StreamDrawUsage);\n\tdustGeo.setAttribute('activate', activateBuffer);\n\n\tconst dustMeshFront = new THREE.InstancedMesh(dustGeo, mat, numDust);\n\tconst dustMeshLeft = new THREE.InstancedMesh(dustGeo, mat, numDust);\n\n\tdust.meshFront = dustMeshFront;\n\tdust.meshLeft = dustMeshLeft;\n\tdust.geo = dustGeo;\n\tdust.mat = mat;\n\tdust.posBuffer = pointBuffer;\n\tdust.activateBuffer = activateBuffer;\n\tdust.velocities = velocities;\n\tdust.pos = new THREE.Vector3();\n\tdust.vec1 = new THREE.Vector3();\n\tdust.moveForce = new THREE.Vector3();\n\n\treturn dust;\n\n}\n\nfunction updateDust(deltaTime) {\n\n\tconst border = 0.5;\n\n\tfor (let i = 0; i < numDust; i++) {\n\n\t\tlet x = dust.posBuffer.array[i * 3];\n\t\tlet y = dust.posBuffer.array[i * 3 + 1];\n\t\tlet z = dust.posBuffer.array[i * 3 + 2];\n\n\t\tlet v = dust.velocities[i];\n\n\t\tif (x < -border) {\n\n\t\t\tv.x = Math.abs(v.x);\n\n\t\t} else if (x > border) {\n\n\t\t\tv.x = -Math.abs(v.x);\n\n\t\t}\n\n\t\tif (y < -border) {\n\n\t\t\tv.y = Math.abs(v.y);\n\n\t\t} else if (y > border) {\n\n\t\t\tv.y = -Math.abs(v.y);\n\n\t\t}\n\n\t\tif (z < -border) {\n\n\t\t\tv.z = Math.abs(v.z);\n\n\t\t} else if (z > border) {\n\n\t\t\tv.z = -Math.abs(v.z);\n\n\t\t}\n\n\t\tdust.moveForce.set(0.0, 0.0, 0.0);\n\t\tfor (let i = 0; i < agents.length; i++) {\n\n\t\t\tlet agent = agents[i];\n\n\t\t\tfor (let j = 0; j < wanderSettings.numTrailSegments; j++) {\n\n\t\t\t\tdust.pos.set(x, y, z);\n\t\t\t\tdust.vec1.copy(agent.wander.trailSegments[j]);\n\t\t\t\tlet dist = dust.vec1.distanceToSquared(dust.pos);\n\t\t\t\tif (dist < wanderSettings.dustAvoidDist) {\n\n\t\t\t\t\tlet forceMult = (wanderSettings.dustAvoidDist - dist) * 0.4;\n\t\t\t\t\tdust.vec1.copy(dust.pos).sub(agent.wander.trailSegments[j]).normalize().multiplyScalar(forceMult);\n\t\t\t\t\tdust.moveForce.add(dust.vec1);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tdust.activateBuffer.array[i] = dust.moveForce.lengthSq() * 15.0;\n\n\t\tdust.vec1.copy(v).add(dust.moveForce);\n\n\t\tx += dust.vec1.x * deltaTime;\n\t\ty += dust.vec1.y * deltaTime;\n\t\tz += dust.vec1.z * deltaTime;\n\t\tdust.posBuffer.setXYZ(i, x, y, z);\n\n\t}\n\tdust.posBuffer.needsUpdate = true;\n\tdust.activateBuffer.needsUpdate = true;\n\n}\n\n//\n//vis1 - front/back\n//\n\nconst vis1SpikeVert = `\n\n#define PI 3.141592653589793\nattribute float t;\nattribute float activate;\nuniform vec3 col1_1;\nuniform vec3 col1_2;\nuniform vec3 col2_1;\nuniform vec3 col2_2;\nvarying vec3 vCol;\nuniform vec3 groupPos;\nuniform vec3 groupDir;\nuniform float uTime;\n\nvoid main() {\n\n\tvec4 vPos = vec4( position, 1.0 );\n\n\tvPos *= smoothstep( t * 8.0 + 0.2, t * 8.0 + 1.0, uTime );\t\n\n\tfloat spikeY = 0.06;\n\tif ( vPos.y > 0.05 ) {\n\t\n\t\tvPos.y += 0.07 * activate;\n\t\tspikeY = vPos.y;\n\t\n\t}\t\n\t\n    vec4 iPos = instanceMatrix * vPos;\n    vec4 worldPos = modelMatrix * iPos;\n    vec4 viewPos = viewMatrix * worldPos;\n\tvec4 worldNormal = instanceMatrix * vec4( normal, 1.0 );\n\tworldNormal = normalize( modelViewMatrix * worldNormal );\n\t\n\tvec3 lightDir = normalize( vec3( -1.0, 0.5, 0.0 ) );\n\t\n\tvec3 vCol1 = col1_1;\t\n\tvec3 vCol2 = col2_1;\n\n\tfloat dir = dot ( cameraPosition - groupPos, groupDir );\n\tfloat dirT = smoothstep( -0.01, 0.01, dir );\n\n\tvCol = mix( vCol1, vCol2, dirT ) * vec3( 1.0 + activate );\n\tvCol *= smoothstep( 0.04, spikeY, vPos.y );\n\t\n    gl_Position = projectionMatrix * viewPos;\n\n}\n`;\n\nconst vis1SpikeFrag = `\n\nvarying vec3 vCol;\n\nvoid main() {\n\n    gl_FragColor = vec4( vCol, 1.0 );\n\n}\n`;\n\nconst vis1BodyVert = `\n\n#define PI 3.141592653589793\nattribute vec3 iPos;\nattribute vec3 rndPos;\nattribute vec3 dir;\nattribute float t;\nuniform vec3 col1;\nuniform vec3 col2;\nuniform float uTime;\nvarying vec3 vCol;\n\nvoid main() {\n\t\n\tfloat scXY = smoothstep( 0.0, 0.1, t ) * ( 1.0 - smoothstep( 0.9, 1.0, t ) );\n\tfloat sc = max( scXY * 0.2 + sin( t * PI * 2.0 * 3.0 + uTime * -3.0 ) * scXY * 0.2, 0.3 );\n\tfloat rndMult = max ( scXY * 0.2 + 0.3 + sin( t * PI * 2.0 * 5.0 - uTime * 4.0 ) * 0.5 + 0.5, 0.1 ) * 0.5;\n\n\tvec3 pos = position;\n\tfloat theta = t * PI * 50.0 + uTime * 10.0;\n\tpos.x += cos( theta ) * 0.02 * ( 1.0 - scXY );\n\tpos.y += sin( theta ) * 0.02 * ( 1.0 - scXY );\n\tpos.z += scXY * -0.1;\n\tpos *= sc;\n\n\tvec3 vPos = pos + rndPos * rndMult;\n\n\tvec4 mvPos = modelViewMatrix * vec4( iPos, 1.0 );\n\tmvPos.xyz += vPos;\n\tgl_Position = projectionMatrix * mvPos;\n\t\n\tvec3 worldPos = ( modelMatrix * vec4( iPos, 1.0 ) ).xyz;\n\tvCol = mix( col1, col2, smoothstep( -0.5, 0.5, dot( cameraPosition - worldPos, dir ) ) );\n\n}\n`;\n\nconst vis1BodyFrag = `\n\nvarying vec3 vCol;\n\nvoid main() {\n\n    gl_FragColor = vec4( vCol, 1.0 );\n\n}\n`;\n\n\n\nfunction vis1(faceGroup) {\n\n\t//vis\n\tconst vis = {};\n\n\tvis.spineElemR = 0.01;\n\tvis.spineElemH = 0.02;\n\tvis.bodyElemScale = 0.015;\n\tvis.numSpineInstances = 512;\n\tvis.numBodyInstances = 512;\n\tvis.numSpineLoops = 58;\n\tvis.visAgents = [];\n\tvis.cols1 = [0xdf4266, 0xd246d8];\n\tvis.cols2 = [0x44bfd9, 0xd743cb];\n\tvis.bodyCols = [0x43adc8, 0xc84f43];\n\n\tvis.pos = new THREE.Vector3();\n\tvis.vec1 = new THREE.Vector3();\n\tvis.vec2 = new THREE.Vector3();\n\tvis.vec3 = new THREE.Vector3();\n\tvis.mat3 = new THREE.Matrix3();\n\tvis.mat4 = new THREE.Matrix4();\n\tvis.matRot4 = new THREE.Matrix4();\n\tvis.q1 = new THREE.Quaternion();\n\tvis.q2 = new THREE.Quaternion();\n\tvis.q3 = new THREE.Quaternion();\n\tvis.scale = new THREE.Vector3();\n\tvis.forward = new THREE.Vector3(0, 0, 1.0);\n\tvis.up = new THREE.Vector3(0, 1.0, 0);\n\n\tvis.tick = 0;\n\n\tvis.faceGroup = faceGroup;\n\n\tfor (let i = 0; i < agents.length; i++) {\n\n\t\tconst spikeUniforms = {\n\t\t\t\"col1_1\": { value: new THREE.Color(vis.cols1[i]) },\n\t\t\t\"col1_2\": { value: new THREE.Color(vis.cols1[1 - i]) },\n\t\t\t\"col2_1\": { value: new THREE.Color(vis.cols2[i]) },\n\t\t\t\"col2_2\": { value: new THREE.Color(vis.cols2[1 - i]) },\n\t\t\t\"groupPos\": { value: frontPos },\n\t\t\t\"groupDir\": { value: frontDir },\n\t\t\t\"uTime\": { value: 0 }\n\t\t};\n\t\tconst spikeMat = new THREE.ShaderMaterial({ uniforms: spikeUniforms, vertexShader: vis1SpikeVert, fragmentShader: vis1SpikeFrag });\n\t\t//mat.blending = THREE.AdditiveBlending;\n\t\t//const mat = new THREE.MeshBasicMaterial( { color: vis.cols[ i ] } );\n\n\t\tconst geo = new THREE.ConeGeometry(vis.spineElemR, vis.spineElemH, 5, 1);\n\t\tgeo.translate(0, vis.spineElemH * 0.5 + 0.04, 0);\n\n\t\tconst spikeMesh = new THREE.InstancedMesh(geo, spikeMat, vis.numSpineInstances);\n\t\tspikeMesh.instanceMatrix.setUsage(THREE.StreamDrawUsage);\n\t\tfaceGroup.add(spikeMesh);\n\n\t\tconst bodyUniforms = {\n\t\t\t\"col1\": { value: new THREE.Color(vis.bodyCols[i]) },\n\t\t\t\"col2\": { value: new THREE.Color(vis.bodyCols[1 - i]) },\n\t\t\t\"uTime\": { value: 0 }\n\t\t};\n\t\t\n\t\tconst bodyMat = new THREE.ShaderMaterial({ uniforms: bodyUniforms, vertexShader: vis1BodyVert, fragmentShader: vis1BodyFrag });\n\t\tbodyMat.blending = THREE.AdditiveBlending;\n\n\t\tconst bodyGeo = new THREE.CircleGeometry(vis.bodyElemScale, 7);\n\t\t\n\t\tconst bodyMesh = new THREE.InstancedMesh(bodyGeo, bodyMat, vis.numBodyInstances);\n\t\tfaceGroup.add(bodyMesh);\n\n\t\tconst agentData = { agent: agents[i], spikeMesh: spikeMesh, bodyMesh: bodyMesh, spikeUniforms: spikeUniforms, bodyUniforms: bodyUniforms, spikeData: [] };\n\n\t\tfor (let i = 0; i < vis.numSpineInstances; i++) {\n\n\t\t\tagentData.spikeData.push({ q: new THREE.Quaternion() });\n\n\t\t}\n\n\t\tconst bodyDirs = new Float32Array(vis.numBodyInstances * 3);\n\t\tconst bodyIPos = new Float32Array(vis.numBodyInstances * 3);\n\t\tconst bodyRndPos = new Float32Array(vis.numBodyInstances * 3);\n\t\tconst bodyT = new Float32Array(vis.numBodyInstances);\n\t\tfor (let i = 0; i < vis.numBodyInstances; i++) {\n\n\t\t\tlet rnd = new THREE.Vector3().randomDirection().multiplyScalar(0.05);\n\t\t\tbodyRndPos[i * 3] = rnd.x;\n\t\t\tbodyRndPos[i * 3 + 1] = rnd.y;\n\t\t\tbodyRndPos[i * 3 + 2] = rnd.z;\n\t\t\tbodyDirs[i * 3] = 0;\n\t\t\tbodyDirs[i * 3 + 1] = 0;\n\t\t\tbodyDirs[i * 3 + 2] = 0;\n\n\t\t\tbodyT[i] = i / (vis.numBodyInstances - 1);\n\n\t\t}\n\n\t\tconst spikeT = new Float32Array(vis.numSpineInstances);\n\t\tfor (let i = 0; i < vis.numSpineInstances; i++) {\n\n\t\t\tspikeT[i] = i / (vis.numSpineInstances - 1);\n\n\t\t}\n\t\t\n\t\tconst bodyIposBuffer = new THREE.InstancedBufferAttribute(bodyIPos, 3);\n\t\tbodyIposBuffer.setUsage(THREE.StreamDrawUsage);\n\t\tbodyGeo.setAttribute('iPos', bodyIposBuffer);\n\t\tconst bodyDirsBuffer = new THREE.InstancedBufferAttribute(bodyDirs, 3);\n\t\tbodyDirsBuffer.setUsage(THREE.StreamDrawUsage);\n\t\tbodyGeo.setAttribute('dir', bodyDirsBuffer);\n\t\tbodyGeo.setAttribute('rndPos', new THREE.InstancedBufferAttribute(bodyRndPos, 3));\n\t\tbodyGeo.setAttribute('t', new THREE.InstancedBufferAttribute(bodyT, 1));\n\n\t\tconst spikeActivates = new Float32Array(vis.numSpineInstances);\n\t\tconst spikeActivateBuffer = new THREE.InstancedBufferAttribute(spikeActivates, 1);\n\t\tspikeActivateBuffer.setUsage(THREE.StreamDrawUsage);\n\t\tgeo.setAttribute('activate', spikeActivateBuffer);\t\t\n\t\tgeo.setAttribute('t', new THREE.InstancedBufferAttribute(spikeT, 1));\n\n\t\tvis.visAgents.push(agentData);\n\n\t}\n\n\tvis.update = function (deltaTime, time) {\n\n\t\tthis.tick += deltaTime;\n\n\t\tlet visAgent, visAgentWander, otherVisAgent;\n\t\tfor (let j = 0; j < vis.visAgents.length; j++) {\n\n\t\t\tvisAgent = this.visAgents[j];\n\t\t\totherVisAgent = this.visAgents[1 - j];\n\t\t\tvisAgentWander = visAgent.agent.wander;\n\t\t\tvisAgent.bodyUniforms.uTime.value = this.tick;\n\t\t\tvisAgent.spikeUniforms.groupPos.value = frontPos;\n\t\t\tvisAgent.spikeUniforms.groupDir.value = frontDir;\n\t\t\tvisAgent.spikeUniforms.uTime.value = this.tick;\n\n\t\t\tlet activates = visAgent.spikeMesh.geometry.getAttribute(\"activate\");\n\n\t\t\tfor (let i = 0; i < this.numSpineInstances; i++) {\n\n\t\t\t\tlet t = i / this.numSpineInstances;\n\t\t\t\tlet segmentI = Math.floor(t * visAgentWander.numTrailSegments);\n\t\t\t\tlet segmentT = t * visAgentWander.numTrailSegments - Math.floor(t * visAgentWander.numTrailSegments);\n\t\t\t\tlet spikeData = visAgent.spikeData[i];\n\n\t\t\t\tif (segmentI < visAgentWander.numTrailSegments - 1) {\n\n\t\t\t\t\tthis.pos.copy(visAgentWander.trailSegments[segmentI]).lerp(visAgentWander.trailSegments[segmentI + 1], segmentT);\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis.pos.copy(visAgentWander.trailSegments[segmentI]);\n\n\t\t\t\t}\n\n\n\t\t\t\tif (segmentI == 0) {\n\n\t\t\t\t\tthis.vec2.copy(this.pos);\n\t\t\t\t\tthis.vec2.add(this.vec1.copy(visAgentWander.trailSegments[0]).sub(visAgentWander.trailSegments[1]).normalize());\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis.vec2.copy(this.pos);\n\t\t\t\t\tthis.vec2.add(this.vec1.copy(visAgentWander.trailSegments[segmentI - 1]).sub(visAgentWander.trailSegments[segmentI]).normalize());\n\n\t\t\t\t}\n\n\t\t\t\tthis.matRot4.lookAt(this.pos, this.vec2, this.up);\n\t\t\t\tthis.q1.setFromRotationMatrix(this.matRot4);\n\n\t\t\t\tthis.q2.setFromAxisAngle(this.forward, t * Math.PI * 2 * this.numSpineLoops + this.tick * 1.0);\n\t\t\t\tthis.q1.multiply(this.q2);\n\n\t\t\t\tspikeData.q.slerp(this.q1, deltaTime * 2.0);\n\n\t\t\t\tlet scXY = THREE.MathUtils.smoothstep(t, 0, 0.1) * (1.0 - THREE.MathUtils.smoothstep(t, 0.9, 1.0)) * 1.0;\n\t\t\t\tlet sc = Math.max(scXY + Math.sin(t * Math.PI * 2 * 30.0 + this.tick * -3.0) * (scXY * 0.9), 0.3);\n\t\t\t\tsc = scXY;\n\t\t\t\tthis.scale.setScalar(sc);\n\n\t\t\t\tlet rndMult = Math.max(scXY + Math.sin(t * Math.PI * 4) * 0.4 + Math.sin(t * Math.PI * 5 - this.tick * 4.0) * 0.4, 0.1);\n\n\t\t\t\tthis.mat4.compose(this.pos, spikeData.q, this.scale);\n\n\t\t\t\tvisAgent.spikeMesh.setMatrixAt(i, this.mat4);\n\t\t\t\t\n\t\t\t\tlet closestDist = 1000.0;\n\t\t\t\tlet dist;\n\t\t\t\tlet maxDist = 0.04;\n\t\t\t\tfor ( let k = 0; k < otherVisAgent.agent.wander.trailSegments.length; k++ ) {\n\t\t\t\t\t\n\t\t\t\t\tdist = this.pos.distanceToSquared( otherVisAgent.agent.wander.trailSegments[ k ] );\n\t\t\t\t\tif ( dist < closestDist ) {\n\t\t\t\t\t\t\n\t\t\t\t\t\tclosestDist = dist;\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tactivates.array[ i ] = ( maxDist - Math.min( closestDist, maxDist ) ) / maxDist;\n\t\t\t\t\n\t\t\t}\n\t\t\tactivates.needsUpdate = true;\n\n\n\t\t\tlet bodyDirs = visAgent.bodyMesh.geometry.getAttribute(\"dir\");\n\t\t\tlet bodyIPos = visAgent.bodyMesh.geometry.getAttribute(\"iPos\");\n\n\t\t\tfor (let i = 0; i < this.numBodyInstances; i++) {\n\n\t\t\t\tlet t = i / this.numBodyInstances;\n\t\t\t\tlet segmentI = Math.floor(t * visAgentWander.numTrailSegments);\n\t\t\t\tlet segmentT = t * visAgentWander.numTrailSegments - Math.floor(t * visAgentWander.numTrailSegments);\n\n\t\t\t\tif (segmentI < visAgentWander.numTrailSegments - 1) {\n\n\t\t\t\t\tthis.pos.copy(visAgentWander.trailSegments[segmentI]).lerp(visAgentWander.trailSegments[segmentI + 1], segmentT);\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis.pos.copy(visAgentWander.trailSegments[segmentI]);\n\n\t\t\t\t}\n\n\n\t\t\t\tif (segmentI == 0) {\n\n\t\t\t\t\tthis.vec2.copy(this.pos);\n\t\t\t\t\tthis.vec2.add(this.vec1.copy(visAgentWander.trailSegments[0]).sub(visAgentWander.trailSegments[1]).normalize());\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis.vec2.copy(this.pos);\n\t\t\t\t\tthis.vec2.add(this.vec1.copy(visAgentWander.trailSegments[segmentI - 1]).sub(visAgentWander.trailSegments[segmentI]).normalize());\n\n\t\t\t\t}\n\n\t\t\t\tbodyDirs.setXYZ(i, this.vec2.x, this.vec2.y, this.vec2.z);\n\t\t\t\tbodyIPos.setXYZ(i, this.pos.x, this.pos.y, this.pos.z);\n\n\t\t\t}\n\n\t\t\tvisAgent.spikeMesh.instanceMatrix.needsUpdate = true;\n\t\t\tbodyDirs.needsUpdate = true;\n\t\t\tbodyIPos.needsUpdate = true;\n\n\t\t}\n\n\t}\n\n\treturn vis;\n\n}\n\n//\n//vis2 - left/right\n//\n\nconst vis2SpikeVert = `\n\n#define PI 3.141592653589793\nuniform vec3 col1_1;\nuniform vec3 col1_2;\nuniform vec3 col2_1;\nuniform vec3 col2_2;\nuniform vec3 groupPos;\nuniform vec3 groupDir;\nuniform float uTime;\nattribute float t;\nvarying vec3 vCol;\n\nvoid main() {\n\n\tvec4 vPos = vec4( position, 1.0 );\n\t\n\tvPos *= smoothstep( t * 8.0 + 0.2, t * 8.0 + 1.0, uTime );\t\n\t\n    vec4 iPos = instanceMatrix * vPos;\n    vec4 worldPos = modelMatrix * iPos;\n    vec4 viewPos = viewMatrix * worldPos;\n\n\tvec3 groupToCam = cameraPosition - groupPos;\n\tfloat dir = dot ( groupToCam, groupDir );\n\tfloat dirT = smoothstep( -0.01, 0.01, dir );\n\n\tvec3 lightDir = normalize( vec3( 0.0, 1.0, 0.0 ) );\n\tvec3 viewDir = cameraPosition - worldPos.xyz;\n\tvec3 worldNormal = ( instanceMatrix * ( vec4( normal, 1.0 ) ) ).xyz;\n\n\n\tvec3 vCol1 = mix( col1_1, col1_2, max( sin( t * PI * 2.0 + uTime * 0.5 ), 0.0 ) );\n\t\n\tvec3 vCol2 = mix( col2_1, col2_2, smoothstep( -0.2, 0.2, iPos.y ) );\n\t\n\tlightDir = normalize( vec3( 1.0, 1.0, -1.0 ) );\n\t\n\tvCol1 = mix( vCol1 * 0.7, vCol1 * 1.8, clamp( dot( lightDir, normalize( worldNormal ) ), 0.0, 1.0 ) );\n\t\n\tvCol2 = mix( vCol2 * 0.2, vCol2 * 1.8, clamp( dot( lightDir, normalize( worldNormal ) ), 0.0, 1.0 ) );\n\t\n\tvCol = mix( vCol1, vCol2, dirT ) * smoothstep( 0.05, 0.09, vPos.y );\n\t\t\n    gl_Position = projectionMatrix * viewPos;\n\n}\n`;\n\nconst vis2SpikeFrag = `\n\nuniform float uTime;\nvarying vec3 vCol;\n\nvoid main() {\n\n    gl_FragColor = vec4( vCol, 1.0 );\n\n}\n`;\n\nconst vis2BodyVert = `\n\n#define PI 3.141592653589793\nattribute vec3 iPos;\nattribute vec3 rndPos;\nattribute vec3 dir;\nattribute float t;\nuniform vec3 col1;\nuniform vec3 col2;\nuniform float uTime;\nvarying vec3 vCol;\n\nvoid main() {\n\t\n\tfloat scXY = smoothstep( 0.0, 0.1, t ) * ( 1.0 - smoothstep( 0.9, 1.0, t ) ) * 0.2;\n\tfloat sc = max( scXY + sin( t * PI * 2.0 * 30.0 + uTime * -3.0 ) * scXY, 0.3 );\n\tfloat rndMult = max ( scXY + sin( t * PI * 4.0 ) * 0.4 + sin( t * PI * 5.0 - uTime * 4.0 ) * 0.4, 0.1 );\n\n\tvec3 pos = position;\n\tpos *= sc;\n\n\tvec3 vPos = pos + rndPos * rndMult;\n\n\tvec4 mvPos = modelViewMatrix * vec4( iPos, 1.0 );\n\tmvPos.xyz += vPos;\n\tgl_Position = projectionMatrix * mvPos;\n\t\n\tvec3 worldPos = ( modelMatrix * vec4( iPos, 1.0 ) ).xyz;\n\tvCol = mix( col1, col2, smoothstep( -0.8, 0.8, dot( cameraPosition - worldPos, dir ) ) );\n\n}\n`;\n\nconst vis2BodyFrag = `\n\nuniform float uTime;\n\nvarying vec3 vCol;\n\nvoid main() {\n\n    gl_FragColor = vec4( vCol, 1.0 );\n\n}\n`;\n\n\n\nfunction vis2(faceGroup) {\n\n\t//vis\n\tconst vis = {};\n\n\tvis.spineElemR = 0.01;\n\tvis.spineElemH = 0.04;\n\tvis.bodyElemScale = 0.02;\n\tvis.numSpineInstances = 1024;\n\tvis.numBodyInstances = 512;\n\tvis.numSpineLoops = 323;\n\tvis.visAgents = [];\n\tvis.cols1 = [0x3b85ff, 0xbc3bff];\n\tvis.cols2 = [0xff4c4c, 0x45e6af];\n\tvis.bodyCols = [0x831230, 0x194db7];\n\n\tvis.pos = new THREE.Vector3();\n\tvis.vec1 = new THREE.Vector3();\n\tvis.vec2 = new THREE.Vector3();\n\tvis.vec3 = new THREE.Vector3();\n\tvis.mat3 = new THREE.Matrix3();\n\tvis.mat4 = new THREE.Matrix4();\n\tvis.matRot4 = new THREE.Matrix4();\n\tvis.q1 = new THREE.Quaternion();\n\tvis.q2 = new THREE.Quaternion();\n\tvis.q3 = new THREE.Quaternion();\n\tvis.scale = new THREE.Vector3();\n\tvis.forward = new THREE.Vector3(0, 0, 1.0);\n\tvis.up = new THREE.Vector3(0, 1.0, 0);\n\n\tvis.tick = 0;\n\n\tvis.faceGroup = faceGroup;\n\n\tfor (let i = 0; i < agents.length; i++) {\n\n\t\tconst spikeUniforms = {\n\t\t\t\"col1_1\": { value: new THREE.Color(vis.cols1[i]) },\n\t\t\t\"col1_2\": { value: new THREE.Color(vis.cols1[1 - i]) },\n\t\t\t\"col2_1\": { value: new THREE.Color(vis.cols2[i]) },\n\t\t\t\"col2_2\": { value: new THREE.Color(vis.cols2[1 - i]) },\n\t\t\t\"groupPos\": { value: frontPos },\n\t\t\t\"groupDir\": { value: frontDir },\n\t\t\t\"uTime\": { value: 0 }\n\t\t};\n\n\t\tconst spikeMat = new THREE.ShaderMaterial({ uniforms: spikeUniforms, vertexShader: vis2SpikeVert, fragmentShader: vis2SpikeFrag });\n\t\t//mat.blending = THREE.AdditiveBlending;\n\n\t\tconst geo = new THREE.ConeGeometry(vis.spineElemR, vis.spineElemH, 4, 1);\n\t\tgeo.translate(0, vis.spineElemH * 0.5 + 0.05, 0);\n\n\t\tconst spikeMesh = new THREE.InstancedMesh(geo, spikeMat, vis.numSpineInstances);\n\t\tspikeMesh.instanceMatrix.setUsage(THREE.StreamDrawUsage);\n\t\tfaceGroup.add(spikeMesh);\t\t\n\n\t\tconst bodyUniforms = {\n\t\t\t\"col1\": { value: new THREE.Color(vis.bodyCols[i]) },\n\t\t\t\"col2\": { value: new THREE.Color(vis.bodyCols[1 - i]) },\n\t\t\t\"uTime\": { value: 0 }\n\t\t};\n\t\tconst bodyMat = new THREE.ShaderMaterial({ uniforms: bodyUniforms, vertexShader: vis2BodyVert, fragmentShader: vis2BodyFrag });\n\t\tbodyMat.blending = THREE.AdditiveBlending;\n\n\t\t//const bodyGeo = new THREE.IcosahedronGeometry( vis.bodyElemScale, 0 );\n\t\tconst bodyGeo = new THREE.CircleGeometry(vis.bodyElemScale, 8);\n\t\t\n\t\tconst bodyMesh = new THREE.InstancedMesh(bodyGeo, bodyMat, vis.numBodyInstances);\n\t\tfaceGroup.add(bodyMesh);\n\n\t\tconst bodyDirs = new Float32Array(vis.numBodyInstances * 3);\n\t\tconst bodyIPos = new Float32Array(vis.numBodyInstances * 3);\n\t\tconst bodyRndPos = new Float32Array(vis.numBodyInstances * 3);\n\t\tconst bodyT = new Float32Array(vis.numBodyInstances);\n\t\tfor (let i = 0; i < vis.numBodyInstances; i++) {\n\n\t\t\tlet rnd = new THREE.Vector3().randomDirection().multiplyScalar(0.05);\n\t\t\tbodyRndPos[i * 3] = rnd.x;\n\t\t\tbodyRndPos[i * 3 + 1] = rnd.y;\n\t\t\tbodyRndPos[i * 3 + 2] = rnd.z;\n\t\t\t\n\t\t\tbodyDirs[i * 3] = 0;\n\t\t\tbodyDirs[i * 3 + 1] = 0;\n\t\t\tbodyDirs[i * 3 + 2] = 0;\n\n\t\t\tbodyT[i] = i / (vis.numBodyInstances - 1);\n\n\t\t}\n\t\t\n\t\tconst spikeT = new Float32Array(vis.numSpineInstances);\n\t\tfor (let i = 0; i < vis.numSpineInstances; i++) {\n\n\t\t\tspikeT[i] = i / (vis.numSpineInstances- 1);\n\n\t\t}\t\t\n\n\t\tconst bodyIposBuffer = new THREE.InstancedBufferAttribute(bodyIPos, 3);\n\t\tbodyIposBuffer.setUsage(THREE.StreamDrawUsage);\n\t\tbodyGeo.setAttribute('iPos', bodyIposBuffer);\n\t\tconst bodyDirsBuffer = new THREE.InstancedBufferAttribute(bodyDirs, 3);\n\t\tbodyDirsBuffer.setUsage(THREE.StreamDrawUsage);\n\t\tbodyGeo.setAttribute('dir', bodyDirsBuffer);\n\t\tbodyGeo.setAttribute('rndPos', new THREE.InstancedBufferAttribute(bodyRndPos, 3));\n\t\tbodyGeo.setAttribute('t', new THREE.InstancedBufferAttribute(bodyT, 1));\n\n\t\tgeo.setAttribute('t', new THREE.InstancedBufferAttribute(spikeT, 1));\n\n\t\tconst agentData = { agent: agents[i], spikeMesh: spikeMesh, bodyMesh: bodyMesh, spikeUniforms: spikeUniforms, bodyUniforms: bodyUniforms, spikeData: [] };\n\n\t\tfor (let i = 0; i < vis.numSpineInstances; i++) {\n\n\t\t\tagentData.spikeData.push({ q: new THREE.Quaternion() });\n\n\t\t}\t\t\n\n\t\tagentData.bodyDirsBuffer = bodyDirsBuffer;\n\t\tagentData.bodyIposBuffer = bodyIposBuffer;\n\n\t\tvis.visAgents.push(agentData);\n\n\t}\n\n\tvis.update = function (deltaTime, time) {\n\n\t\tthis.tick += deltaTime;\n\n\t\tlet visAgent, visAgentWander, otherVisAgent;\n\t\tfor (let j = 0; j < vis.visAgents.length; j++) {\n\n\t\t\tvisAgent = this.visAgents[j];\n\t\t\totherVisAgent = this.visAgents[1 - j];\n\t\t\tvisAgentWander = visAgent.agent.wander;\n\t\t\tvisAgent.bodyUniforms.uTime.value = this.tick;\n\t\t\tvisAgent.spikeUniforms.groupPos.value = leftPos;\n\t\t\tvisAgent.spikeUniforms.groupDir.value = leftDir;\n\t\t\tvisAgent.spikeUniforms.uTime.value = this.tick;\n\n\t\t\tfor (let i = 0; i < this.numSpineInstances; i++) {\n\n\t\t\t\tlet t = i / this.numSpineInstances;\n\t\t\t\tlet segmentI = Math.floor(t * visAgentWander.numTrailSegments);\n\t\t\t\tlet segmentT = t * visAgentWander.numTrailSegments - Math.floor(t * visAgentWander.numTrailSegments);\n\t\t\t\tlet spikeData = visAgent.spikeData[i];\n\n\t\t\t\tif (segmentI < visAgentWander.numTrailSegments - 1) {\n\n\t\t\t\t\tthis.pos.copy(visAgentWander.trailSegments[segmentI]).lerp(visAgentWander.trailSegments[segmentI + 1], segmentT);\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis.pos.copy(visAgentWander.trailSegments[segmentI]);\n\n\t\t\t\t}\n\n\n\t\t\t\tif (segmentI == 0) {\n\n\t\t\t\t\tthis.vec2.copy(this.pos);\n\t\t\t\t\tthis.vec2.add(this.vec1.copy(visAgentWander.trailSegments[0]).sub(visAgentWander.trailSegments[1]).normalize());\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis.vec2.copy(this.pos);\n\t\t\t\t\tthis.vec2.add(this.vec1.copy(visAgentWander.trailSegments[segmentI - 1]).sub(visAgentWander.trailSegments[segmentI]).normalize());\n\n\t\t\t\t}\n\n\t\t\t\tthis.matRot4.lookAt(this.pos, this.vec2, this.up);\n\t\t\t\tthis.q1.setFromRotationMatrix(this.matRot4);\n\n\t\t\t\tthis.q2.setFromAxisAngle(this.forward, t * Math.PI * 2 * this.numSpineLoops + this.tick * 1.0);\n\t\t\t\tthis.q1.multiply(this.q2);\n\n\t\t\t\tspikeData.q.slerp(this.q1, deltaTime * 2.0);\n\n\t\t\t\tlet scXY = THREE.MathUtils.smoothstep(t, 0, 0.1) * (1.0 - THREE.MathUtils.smoothstep(t, 0.9, 1.0)) * 1.0;\n\t\t\t\tlet sc = Math.max(scXY + Math.sin(t * Math.PI * 2 * 30.0 + this.tick * -3.0) * (scXY * 0.9), 0.3);\n\t\t\t\tsc = scXY;\n\t\t\t\tthis.scale.setScalar(sc);\n\n\t\t\t\tlet rndMult = Math.max(scXY + Math.sin(t * Math.PI * 4) * 0.4 + Math.sin(t * Math.PI * 5 - this.tick * 4.0) * 0.4, 0.1);\n\n\t\t\t\tthis.mat4.compose(this.pos, spikeData.q, this.scale);\n\n\t\t\t\tvisAgent.spikeMesh.setMatrixAt(i, this.mat4);\n\n\t\t\t}\n\n\t\t\tconst bodyDirs = visAgent.bodyDirsBuffer;\n\t\t\tconst bodyIPos = visAgent.bodyIposBuffer;\n\n\t\t\tfor (let i = 0; i < this.numBodyInstances; i++) {\n\n\t\t\t\tlet t = i / this.numBodyInstances;\n\t\t\t\tlet segmentI = Math.floor(t * visAgentWander.numTrailSegments);\n\t\t\t\tlet segmentT = t * visAgentWander.numTrailSegments - Math.floor(t * visAgentWander.numTrailSegments);\n\n\t\t\t\tif (segmentI < visAgentWander.numTrailSegments - 1) {\n\n\t\t\t\t\tthis.pos.copy(visAgentWander.trailSegments[segmentI]).lerp(visAgentWander.trailSegments[segmentI + 1], segmentT);\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis.pos.copy(visAgentWander.trailSegments[segmentI]);\n\n\t\t\t\t}\n\n\n\t\t\t\tif (segmentI == 0) {\n\n\t\t\t\t\tthis.vec2.copy(this.pos);\n\t\t\t\t\tthis.vec2.add(this.vec1.copy(visAgentWander.trailSegments[0]).sub(visAgentWander.trailSegments[1]).normalize());\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis.vec2.copy(this.pos);\n\t\t\t\t\tthis.vec2.add(this.vec1.copy(visAgentWander.trailSegments[segmentI - 1]).sub(visAgentWander.trailSegments[segmentI]).normalize());\n\n\t\t\t\t}\n\n\t\t\t\tbodyDirs.setXYZ(i, this.vec2.x, this.vec2.y, this.vec2.z);\n\t\t\t\tbodyIPos.setXYZ(i, this.pos.x, this.pos.y, this.pos.z);\n\n\t\t\t}\n\n\t\t\tvisAgent.spikeMesh.instanceMatrix.needsUpdate = true;\n\t\t\tbodyDirs.needsUpdate = true;\n\t\t\tbodyIPos.needsUpdate = true;\n\t\t\t\n\t\t}\n\n\t}\n\n\treturn vis;\n\n}\n\n\n\n//\n//vis3 - top/bottom\n//\n\nconst vis3SpikeVert = `\n\nattribute vec3 iPos;\nuniform vec3 col1;\nuniform vec3 col2_1;\nuniform vec3 col2_2;\nvarying vec3 vCol;\nuniform vec3 groupPos;\nuniform vec3 groupDir;\n\nvoid main() {\n\n    vec4 iPos = instanceMatrix * vec4( position, 1.0 );\n    vec4 worldPos = modelMatrix * iPos;\n    vec4 viewPos = viewMatrix * worldPos;\n\n    gl_Position = projectionMatrix * viewPos;\n\n\tvec3 vCol1 = col1;\n\tvCol = vCol1;\t\n\t\n}\n`;\n\nconst vis3SpikeFrag = `\n\nvarying vec3 vCol;\n\nvoid main() {\n\n    gl_FragColor = vec4( vCol, 1.0 );\n\n}\n`;\n\nconst vis3BodyVert = `\n\n#define PI 3.141592653589793\nattribute vec3 iPos;\nattribute vec3 rndPos;\nattribute vec3 dir;\nattribute float t;\nuniform vec3 col1;\nuniform vec3 col2;\nuniform float uTime;\nvarying vec3 vCol;\n\nvoid main() {\n\t\n\tfloat scXY = smoothstep( 0.0, 0.1, t ) * ( 1.0 - smoothstep( 0.9, 1.0, t ) ) * 0.2;\n\tfloat sc = max( scXY + sin( t * PI * 2.0 * 30.0 + uTime * -3.0 ) * scXY, 0.3 );\n\tfloat rndMult = max ( scXY + sin( t * PI * 4.0 ) * 0.4 + sin( t * PI * 5.0 - uTime * 4.0 ) * 0.4, 0.1 );\n\n\tvec3 pos = position;\n\tpos *= sc;\n\n\tvec3 vPos = pos + rndPos * rndMult;\n\n\tvec4 mvPos = modelViewMatrix * vec4( iPos, 1.0 );\n\tmvPos.xyz += vPos;\n\tgl_Position = projectionMatrix * mvPos;\n\t\n\tvec3 worldPos = ( modelMatrix * vec4( iPos, 1.0 ) ).xyz;\n\tvCol = mix( col1, col2, smoothstep( -0.5, 0.5, dot( cameraPosition - worldPos, dir ) ) );\n\n}\n`;\n\nconst vis3BodyFrag = `\n\nuniform float uTime;\n\nvarying vec3 vCol;\n\nvoid main() {\n\n    gl_FragColor = vec4( vCol, 1.0 );\n\n}\n`;\n\n\n\nfunction vis3(faceGroup) {\n\n\t//vis\n\tconst vis = {};\n\n\tvis.spineElemR = 0.01;\n\tvis.spineElemH = 0.04;\n\tvis.bodyElemScale = 0.016;\n\tvis.numSpineInstances = 1024;\n\tvis.numBodyInstances = 512;\n\tvis.numSpineLoops = 323;\n\tvis.visAgents = [];\n\tvis.cols1 = [0xCCCCCC, 0xCCCCCC];\n\tvis.cols2 = [0xCCCCCC, 0xCCCCCC];\n\tvis.bodyCols = [0xFFFFFF, 0xFFFFFF];\n\n\tvis.pos = new THREE.Vector3();\n\tvis.vec1 = new THREE.Vector3();\n\tvis.vec2 = new THREE.Vector3();\n\tvis.vec3 = new THREE.Vector3();\n\tvis.mat3 = new THREE.Matrix3();\n\tvis.mat4 = new THREE.Matrix4();\n\tvis.matRot4 = new THREE.Matrix4();\n\tvis.q1 = new THREE.Quaternion();\n\tvis.q2 = new THREE.Quaternion();\n\tvis.q3 = new THREE.Quaternion();\n\tvis.scale = new THREE.Vector3();\n\tvis.forward = new THREE.Vector3(0, 0, 1.0);\n\tvis.up = new THREE.Vector3(0, 1.0, 0);\n\n\tvis.tick = 0;\n\n\tvis.faceGroup = faceGroup;\n\n\tfor (let i = 0; i < agents.length; i++) {\n\n\t\t//const geo = new THREE.ConeGeometry(vis.spineElemR, vis.spineElemH, 5, 1);\n\t\tconst boxW = 0.002;\n\t\tconst geo = new THREE.BoxGeometry(boxW, boxW, boxW);\n\t\tgeo.translate(0, vis.spineElemH * 0.5 + 0.05, 0);\n\n\t\tconst spikeUniforms = {\n\t\t\t\"col1\": { value: new THREE.Color(vis.cols1[i]) },\n\t\t\t\"col2_1\": { value: new THREE.Color(vis.cols2[i]) },\n\t\t\t\"col2_2\": { value: new THREE.Color(vis.cols2[1 - i]) },\n\t\t\t\"groupPos\": { value: frontPos },\n\t\t\t\"groupDir\": { value: frontDir }\n\n\n\t\t};\n\t\tconst spikeMat = new THREE.ShaderMaterial({ uniforms: spikeUniforms, vertexShader: vis3SpikeVert, fragmentShader: vis3SpikeFrag });\n\t\t//mat.blending = THREE.AdditiveBlending;\n\t\t//const mat = new THREE.MeshBasicMaterial( { color: vis.cols[ i ] } );\n\n\t\tconst spikeMesh = new THREE.InstancedMesh(geo, spikeMat, vis.numSpineInstances);\n\t\tspikeMesh.instanceMatrix.setUsage(THREE.StreamDrawUsage);\n\t\tfaceGroup.add(spikeMesh);\n\t\t\n\t\tconst spikeIPos = new Float32Array(vis.numSpineInstances * 3);\n\t\tconst spikeIposBuffer = new THREE.InstancedBufferAttribute(spikeIPos, 3);\n\t\tspikeIposBuffer.setUsage(THREE.StreamDrawUsage);\n\t\tgeo.setAttribute('iPos', spikeIposBuffer);\n\t\t\n\n\t\tconst bodyUniforms = {\n\t\t\t\"col1\": { value: new THREE.Color(vis.bodyCols[i]) },\n\t\t\t\"col2\": { value: new THREE.Color(vis.bodyCols[1 - i]) },\n\t\t\t\"uTime\": { value: 0 }\n\t\t};\n\t\tconst bodyMat = new THREE.ShaderMaterial({ uniforms: bodyUniforms, vertexShader: vis3BodyVert, fragmentShader: vis3BodyFrag });\n\t\tbodyMat.blending = THREE.AdditiveBlending;\n\n\t\t//const bodyGeo = new THREE.IcosahedronGeometry( vis.bodyElemScale, 0 );\n\t\tconst bodyGeo = new THREE.CircleGeometry(vis.bodyElemScale, 8);\n\t\tconst bodyMesh = new THREE.InstancedMesh(bodyGeo, bodyMat, vis.numBodyInstances);\n\t\tfaceGroup.add(bodyMesh);\n\n\t\tconst agentData = { agent: agents[i], spikeMesh: spikeMesh, bodyMesh: bodyMesh, spikeUniforms: spikeUniforms, bodyUniforms: bodyUniforms, spikeData: [] };\n\n\t\tfor (let i = 0; i < vis.numSpineInstances; i++) {\n\n\t\t\tagentData.spikeData.push({ q: new THREE.Quaternion() });\n\n\t\t}\n\n\t\tconst bodyDirs = new Float32Array(vis.numBodyInstances * 3);\n\t\tconst bodyIPos = new Float32Array(vis.numBodyInstances * 3);\n\t\tconst bodyRndPos = new Float32Array(vis.numBodyInstances * 3);\n\t\tconst bodyT = new Float32Array(vis.numBodyInstances);\n\t\tfor (let i = 0; i < vis.numBodyInstances; i++) {\n\n\t\t\tlet rnd = new THREE.Vector3().randomDirection().multiplyScalar(0.05);\n\t\t\tbodyRndPos[i * 3] = rnd.x;\n\t\t\tbodyRndPos[i * 3 + 1] = rnd.y;\n\t\t\tbodyRndPos[i * 3 + 2] = rnd.z;\n\t\t\tbodyDirs[i * 3] = 0;\n\t\t\tbodyDirs[i * 3 + 1] = 0;\n\t\t\tbodyDirs[i * 3 + 2] = 0;\n\n\t\t\tbodyT[i] = i / (vis.numBodyInstances - 1);\n\n\t\t}\n\n\t\tconst bodyIposBuffer = new THREE.InstancedBufferAttribute(bodyIPos, 3);\n\t\tbodyIposBuffer.setUsage(THREE.StreamDrawUsage);\n\t\tbodyGeo.setAttribute('iPos', bodyIposBuffer);\n\t\tconst bodyDirsBuffer = new THREE.InstancedBufferAttribute(bodyDirs, 3);\n\t\tbodyDirsBuffer.setUsage(THREE.StreamDrawUsage);\n\t\tbodyGeo.setAttribute('dir', bodyDirsBuffer);\n\t\tbodyGeo.setAttribute('rndPos', new THREE.InstancedBufferAttribute(bodyRndPos, 3));\n\t\tbodyGeo.setAttribute('t', new THREE.InstancedBufferAttribute(bodyT, 1));\n\n\t\tvis.visAgents.push(agentData);\n\n\t}\n\n\tvis.update = function (deltaTime, time) {\n\n\t\tthis.tick += deltaTime;\n\n\t\tlet visAgent, visAgentWander;\n\t\tfor (let j = 0; j < vis.visAgents.length; j++) {\n\n\t\t\tvisAgent = this.visAgents[j];\n\t\t\tvisAgentWander = visAgent.agent.wander;\n\t\t\tvisAgent.bodyUniforms.uTime.value = this.tick;\n\t\t\tvisAgent.spikeUniforms.groupPos.value = leftPos;\n\t\t\tvisAgent.spikeUniforms.groupDir.value = leftDir;\n\n\t\t\tlet spikeIPos = visAgent.spikeMesh.geometry.getAttribute(\"iPos\");\n\n\t\t\tfor (let i = 0; i < this.numSpineInstances; i++) {\n\n\t\t\t\tlet t = i / this.numSpineInstances;\n\t\t\t\tlet segmentI = Math.floor(t * visAgentWander.numTrailSegments);\n\t\t\t\tlet segmentT = t * visAgentWander.numTrailSegments - Math.floor(t * visAgentWander.numTrailSegments);\n\t\t\t\tlet spikeData = visAgent.spikeData[ i ];\n\n\t\t\t\tif (segmentI < visAgentWander.numTrailSegments - 1) {\n\n\t\t\t\t\tthis.pos.copy(visAgentWander.trailSegments[segmentI]).lerp(visAgentWander.trailSegments[segmentI + 1], segmentT);\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis.pos.copy(visAgentWander.trailSegments[segmentI]);\n\n\t\t\t\t}\n\n\n\t\t\t\tif (segmentI == 0) {\n\n\t\t\t\t\tthis.vec2.copy(this.pos);\n\t\t\t\t\tthis.vec2.add(this.vec1.copy(visAgentWander.trailSegments[0]).sub(visAgentWander.trailSegments[1]).normalize());\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis.vec2.copy(this.pos);\n\t\t\t\t\tthis.vec2.add(this.vec1.copy(visAgentWander.trailSegments[segmentI - 1]).sub(visAgentWander.trailSegments[segmentI]).normalize());\n\n\t\t\t\t}\n\n\t\t\t\tthis.matRot4.lookAt(this.pos, this.vec2, this.up);\n\t\t\t\tthis.q1.setFromRotationMatrix(this.matRot4);\n\n\t\t\t\tthis.q2.setFromAxisAngle(this.forward, t * Math.PI * 2 * this.numSpineLoops + this.tick * 1.0);\n\t\t\t\tthis.q1.multiply(this.q2);\n\n\t\t\t\tspikeData.q.slerp(this.q1, deltaTime * 2.0);\n\n\t\t\t\tlet scXY = THREE.MathUtils.smoothstep(t, 0, 0.1) * (1.0 - THREE.MathUtils.smoothstep(t, 0.9, 1.0)) * 1.0;\n\t\t\t\tlet sc = Math.max(scXY + Math.sin(t * Math.PI * 2 * 30.0 + this.tick * -3.0) * (scXY * 0.9), 0.3);\n\t\t\t\tsc = scXY;\n\t\t\t\tthis.scale.setScalar(sc);\n\n\t\t\t\tlet rndMult = Math.max(scXY + Math.sin(t * Math.PI * 4) * 0.4 + Math.sin(t * Math.PI * 5 - this.tick * 4.0) * 0.4, 0.1);\n\n\t\t\t\tthis.mat4.compose(this.pos, spikeData.q, this.scale);\n\t\t\t\tthis.pos.setFromMatrixPosition( this.mat4 );\n\n\t\t\t\tvisAgent.spikeMesh.setMatrixAt(i, this.mat4);\n\n\t\t\t}\n\n\n\t\t\tlet bodyDirs = visAgent.bodyMesh.geometry.getAttribute(\"dir\");\n\t\t\tlet bodyIPos = visAgent.bodyMesh.geometry.getAttribute(\"iPos\");\n\n\t\t\tfor (let i = 0; i < this.numBodyInstances; i++) {\n\n\t\t\t\tlet t = i / this.numBodyInstances;\n\t\t\t\tlet segmentI = Math.floor(t * visAgentWander.numTrailSegments);\n\t\t\t\tlet segmentT = t * visAgentWander.numTrailSegments - Math.floor(t * visAgentWander.numTrailSegments);\n\n\t\t\t\tif (segmentI < visAgentWander.numTrailSegments - 1) {\n\n\t\t\t\t\tthis.pos.copy(visAgentWander.trailSegments[segmentI]).lerp(visAgentWander.trailSegments[segmentI + 1], segmentT);\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis.pos.copy(visAgentWander.trailSegments[segmentI]);\n\n\t\t\t\t}\n\n\n\t\t\t\tif (segmentI == 0) {\n\n\t\t\t\t\tthis.vec2.copy(this.pos);\n\t\t\t\t\tthis.vec2.add(this.vec1.copy(visAgentWander.trailSegments[0]).sub(visAgentWander.trailSegments[1]).normalize());\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis.vec2.copy(this.pos);\n\t\t\t\t\tthis.vec2.add(this.vec1.copy(visAgentWander.trailSegments[segmentI - 1]).sub(visAgentWander.trailSegments[segmentI]).normalize());\n\n\t\t\t\t}\n\n\t\t\t\tbodyDirs.setXYZ(i, this.vec2.x, this.vec2.y, this.vec2.z);\n\t\t\t\tbodyIPos.setXYZ(i, this.pos.x, this.pos.y, this.pos.z);\n\n\t\t\t}\n\n\t\t\tvisAgent.spikeMesh.instanceMatrix.needsUpdate = true;\n\t\t\tbodyDirs.needsUpdate = true;\n\t\t\tbodyIPos.needsUpdate = true;\n\t\t\tspikeIPos.needsUpdate = true;\n\n\t\t}\n\n\t}\n\n\treturn vis;\n\n}\n\n//\n//BGs\n//\n\nconst bgVert = `\nuniform vec3 colFront1;\nuniform vec3 colFront2;\nuniform vec3 colFront3;\nuniform vec3 colBack1;\nuniform vec3 colBack2;\nuniform vec3 colBack3;\nuniform vec3 groupPos;\nuniform vec3 groupDir;\nvarying vec4 vCol;\n\nvoid main() {\n\n\tvec4 pos = vec4( position, 1.0 );\n\tvec4 worldPos = modelMatrix * pos;\n\tvec4 viewPos = viewMatrix * worldPos;\n\n\tvec4 vCol1 = mix( vec4( colFront1, 1.0 ), vec4( colFront2, 1.0 ), clamp( worldPos.y, -2.0, 0.0 ) + 0.5 ) ;\n\tvCol1 = mix( vCol1, vec4( colFront3, 1.0 ), smoothstep( 0.0, 1.5, worldPos.y ) ) ;\n\n\tvec4 vCol2 = mix( vec4( colBack1, 1.0 ), vec4( colBack2, 1.0 ), smoothstep( -1.5, -0.5, worldPos.y ) ) ;\n\tvCol2 = mix( vCol2, vec4( colBack3, 1.0 ), smoothstep( -0.5, 0.75, worldPos.y ) ) ;\n\t\n\tfloat dir = dot ( cameraPosition - groupPos, groupDir );\n\t\n\t//vCol1 = vec4( 1.0, 0.0, 0.0, 1.0 );\n\t//vCol2 = vec4( 0.0, 0.0, 1.0, 1.0 );\n\tvCol = mix( vCol1, vCol2, smoothstep( -0.01, 0.01, dir ) );\n\t\n\tgl_Position = projectionMatrix * viewPos;\n\t\n}\n`;\n\nconst bgFrag = `\n#define PI 3.141592653589793\nvarying vec4 vCol;\n\nhighp float rand( const in vec2 uv ) {\n  const highp float a = 12.9898, b = 78.233, c = 43758.5453;\n  highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n  return fract( sin( sn ) * c );\n}\n\nvec3 dithering( vec3 color ) {\n  float grid_position = rand( gl_FragCoord.xy );\n  vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n  dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n  return color + dither_shift_RGB;\n}\n\nvoid main() {\n\t\n\tgl_FragColor = vCol;\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n\t\n}\n`;\n\nfunction createBG(face, uniforms, rot) {\n\n\tconst geo = new THREE.BoxGeometry(1, 1, 1, 1, 30, 1);\n\tconst mat = new THREE.ShaderMaterial({ uniforms: uniforms, vertexShader: bgVert, fragmentShader: bgFrag });\n\tmat.side = THREE.BackSide;\n\tconst mesh = new THREE.Mesh(geo, mat);\n\tmesh.scale.setScalar(3.0);\n\tmesh.rotation.y = rot;\n\tface.add(mesh);\n\n\tconst bgData = {\n\n\t\tmesh: mesh,\n\t\tuniforms: uniforms\n\n\t};\n\n\treturn bgData;\n\n}\n\nfunction updateBGs(data, facePos, faceDir) {\n\n\tdata.uniforms.groupPos.value = facePos;\n\tdata.uniforms.groupDir.value = faceDir;\n\n}\n"
			}]
	}
}